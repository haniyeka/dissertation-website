<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; Background – Dynamic Selection of Parallel Portfolio of Algorithms for Solving Combinatorial Problems</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../chapters/chapter3/IsAlgorithmSelectionWorthItComparingSelectingSingleAlgorithmsandParallelExecution.html" rel="next">
<link href="../../chapters/chapter1/Introduction.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-8eef5ae80df721a84869b784b4d5419f.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-812d013f591176c02f613616752f8d70.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>


</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapters/chapter2/Background.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Background</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">Dynamic Selection of Parallel Portfolio of Algorithms for Solving Combinatorial Problems</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/haniyeka/dissertation-website" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="../../Dynamic-Selection-of-Parallel-Portfolio-of-Algorithms-for-Solving-Combinatorial-Problems.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Abstract</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter1/Introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter2/Background.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Background</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter3/IsAlgorithmSelectionWorthItComparingSelectingSingleAlgorithmsandParallelExecution.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Is Algorithm Selection Worth It? Comparing Selecting Single Algorithms and Parallel Execution</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter4/AutomaticParallelPortfolioSelection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Automatic Parallel Portfolio Selection</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter5/RevisitingParallelPortfolioSelectionwithKLDivergence.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Revisiting Parallel Portfolio Selection with KL Divergence</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter6/ParallelPortfolioSelectionwithParallelDataTraining.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Parallel Portfolio Selection with Parallel Data Training</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter7/DiscussionandConclusion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Discussion and Conclusion</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/appendixA.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Appendix</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#parallel-solvers" id="toc-parallel-solvers" class="nav-link active" data-scroll-target="#parallel-solvers"><span class="header-section-number">3.1</span> Parallel Solvers</a></li>
  <li><a href="#algorithm-selection" id="toc-algorithm-selection" class="nav-link" data-scroll-target="#algorithm-selection"><span class="header-section-number">3.2</span> Algorithm Selection</a></li>
  <li><a href="#algorithm-portfolios-and-scheduling" id="toc-algorithm-portfolios-and-scheduling" class="nav-link" data-scroll-target="#algorithm-portfolios-and-scheduling"><span class="header-section-number">3.3</span> Algorithm Portfolios and Scheduling</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Background</span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Combinatorial problems involve problems whose goal is to find the best arrangement or selection from a finite set of items. These problems mainly focus on assignment, sorting, selection, and optimization tasks such as scheduling and routing. These challenges are common in multiple disciplines, such as computer science, operations research, bioinformatics, and artificial intelligence <span class="citation" data-cites="series/faia/336">(<a href="#ref-series/faia/336" role="doc-biblioref">Biere et al. 2021</a>)</span>. Many combinatorial problems fall into the categories of NP-complete or NP-hard, meaning they can be significantly computationally expensive.</p>
<p>Common examples of these problems include boolean satisfiability (SAT), integer programming (IP), quantified boolean formulas (QBF), constraint satisfaction problem (CSP), and any other NP-complete problems like the 21 Karp NP-complete problems <span class="citation" data-cites="Karp1972">(<a href="#ref-Karp1972" role="doc-biblioref">Karp 1972</a>)</span>. Additionally, NP-hard problems such as the traveling salesman (TSP), answer set programming (ASP), scheduling, and mixed-integer programming (MIP) fall into this category. Over several decades, various algorithms and complex mathematical methods have been developed to solve these problems, which mainly deal with discrete optimization.</p>
<p>Every year, competitions are held to compare the proposed algorithms. For example, the SAT community organized annual SAT competitions to evaluate and benchmark algorithms on various tracks and domains <span class="citation" data-cites="balyo_sat_2017">(<a href="#ref-balyo_sat_2017" role="doc-biblioref">Tomáš Balyo, Heule, and Järvisalo 2017</a>)</span>. Similarly, annual QBF solver evaluations (QBFEVAL), MiniZinc Challenge, ASP Competition, and International Planning Competition exist, focusing on quantified Boolean formulas, constraint programming, ASP and planning solvers, respectively <span class="citation" data-cites="PULINA2019224 Stuckey_Feydy_Schutt_Tack_Fischer_2014 GEBSER_2019 taitler-et-al-aimag2024">(<a href="#ref-PULINA2019224" role="doc-biblioref">Pulina and Seidl 2019</a>; <a href="#ref-Stuckey_Feydy_Schutt_Tack_Fischer_2014" role="doc-biblioref">Stuckey et al. 2014</a>; <a href="#ref-GEBSER_2019" role="doc-biblioref">GEBSER, MARATEA, and RICCA 2019</a>; <a href="#ref-taitler-et-al-aimag2024" role="doc-biblioref">Taitler et al. 2024</a>)</span>.</p>
<p>Many solvers have been proposed and continue to evolve, leading to significant improvements in both efficiency and effectiveness. In addition to exact solvers <span class="citation" data-cites="gerhard_j__woeginger_2002">(<a href="#ref-gerhard_j__woeginger_2002" role="doc-biblioref">Woeginger 2002</a>)</span>, researchers have also explored approximation algorithms <span class="citation" data-cites="books/daglib/0030297">(<a href="#ref-books/daglib/0030297" role="doc-biblioref">Williamson and Shmoys 2011</a>)</span> and heuristics <span class="citation" data-cites="10.5555/525">(<a href="#ref-10.5555/525" role="doc-biblioref">Pearl 1984</a>)</span> as alternatives to achieve solutions close to the optimum, particularly in cases where exact solutions are computationally infeasible. These methods often leverage problem-specific knowledge to guide the search process, and they often sacrifice optimality for speed and produce suboptimal solutions.</p>
<p>Moreover, the inherent difficulty of these problems means that no polynomial-time solutions are known, and there is no one-size-fits-all solution to solve them. The "No Free Lunch" theorem formalizes the idea that, when considering every possible problem, no algorithm outperforms others on average; they all have equivalent performance <span class="citation" data-cites="585893">(<a href="#ref-585893" role="doc-biblioref">Wolpert and Macready 1997</a>)</span>. It is the problem-specific performance that makes some algorithms appear to be better suited for certain domains <span class="citation" data-cites="585893">(<a href="#ref-585893" role="doc-biblioref">Wolpert and Macready 1997</a>)</span>. The performance of any algorithm is limited by the specific characteristics of the problem instance it encounters. The results of <span class="citation" data-cites="10.1007/978-3-540-30201-8_33">(<a href="#ref-10.1007/978-3-540-30201-8_33" role="doc-biblioref">Nudelman et al., n.d.</a>)</span> contribute to a deeper understanding of the relationship between the characteristics of the instance (that is, the number of clauses and variables in the SAT), which is known to correlate with the difficulty of the problem.</p>
<p>In the realm of algorithm development, both sequential and parallel solvers have been extensively studied. Theoretically, many problem-solving approaches were originally sequential. For instance, in the SAT domain, Davis-Putnam-Loveland-Logemann (DPLL) algorithm <span class="citation" data-cites="10.1145/368273.368557">(<a href="#ref-10.1145/368273.368557" role="doc-biblioref">M. Davis, Logemann, and Loveland 1962</a>)</span> was initially designed to be sequential. Sequential solvers generally operate without awareness of available resources and do not dynamically adapt to them. The results of <span class="citation" data-cites="10.1007/978-3-642-16242-8_37">(<a href="#ref-10.1007/978-3-642-16242-8_37" role="doc-biblioref">Hölldobler, Manthey, and Saptawijaya 2010</a>)</span> have revealed that the performance and efficiency of a sequential solver depend heavily on hardware resources and low-level processing. This underscores the need to utilize parallel resources in problem-solving to improve the performance.</p>
<section id="parallel-solvers" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="parallel-solvers"><span class="header-section-number">3.1</span> Parallel Solvers</h2>
<p>Parallel solvers then emerged as multicore architectures became increasingly accessible. Initially, the first parallel SAT solvers utilized single-core CPUs, with multiple units communicating over a network and employing the leader-follower model <span class="citation" data-cites="holldobler_short_2011">(<a href="#ref-holldobler_short_2011" role="doc-biblioref">Hölldobler et al. 2011</a>)</span>. This approach is showcased by PMSat, a parallel version of the sequential MiniSAT solver <span class="citation" data-cites="journals/jsat/GilFS09">(<a href="#ref-journals/jsat/GilFS09" role="doc-biblioref">Gil, Flores, and Silveira 2009</a>)</span>, as well as the PSATO solvers <span class="citation" data-cites="ZHANG1996543">(<a href="#ref-ZHANG1996543" role="doc-biblioref">ZHANG, BONACINA, and HSIANG 1996</a>)</span> and PaSAT <span class="citation" data-cites="SINZ2001205">(<a href="#ref-SINZ2001205" role="doc-biblioref">Sinz, Blochinger, and Küchlin 2001</a>)</span>, which introduced search-space partitioning between processing units communicating over MPI in distributed systems <span class="citation" data-cites="10.1007/978-3-642-16242-8_27">(<a href="#ref-10.1007/978-3-642-16242-8_27" role="doc-biblioref">Hyvärinen, Junttila, and Niemelä 2010</a>)</span>. Additionally, advancements in algorithm design made the development of parallel solvers possible. For example, in the SAT domain, the transition from DPLL solvers to Conflict-Driven Clause Learning (CDCL) solvers <span class="citation" data-cites="biere2009conflict">(<a href="#ref-biere2009conflict" role="doc-biblioref">Biere et al. 2009</a>)</span>, divide-and-conquer techniques <span class="citation" data-cites="lefrioux">(<a href="#ref-lefrioux" role="doc-biblioref">Le Frioux 2019</a>)</span>, and the implementation of restart strategies <span class="citation" data-cites="10.1007/978-3-540-85110-3_11">(<a href="#ref-10.1007/978-3-540-85110-3_11" role="doc-biblioref">Hyvärinen, Junttila, and Niemelä 2008</a>)</span> facilitated the parallelization of existing algorithm designs. These design let the solvers share the learned clauses or split search spaces between processing units.</p>
<p>Following the emergence of shared memory architectures, parallel solvers started to exploit multicore CPUs with shared memory among cores <span class="citation" data-cites="10.1007/11752578_46">(<a href="#ref-10.1007/11752578_46" role="doc-biblioref">Singer and Vagner 2006</a>)</span>. Modern parallel solvers inherited the methods developed from earlier distributed parallelization approaches. For example, the parallel SAT solver, Plingeling <span class="citation" data-cites="plingeling">(<a href="#ref-plingeling" role="doc-biblioref">Biere 2012</a>)</span>, inherits its algorithm design from the sequential Lingeling solver and incorporates a clause-sharing technique among cores for SAT solving. However, in earlier versions of Plingeling, despite using shared-memory systems, clauses were copied by each core. As noted in <span class="citation" data-cites="Biere2013LingelingPA conf/sat/AignerBKNP13">(<a href="#ref-Biere2013LingelingPA" role="doc-biblioref">Biere 2013</a>; <a href="#ref-conf/sat/AignerBKNP13" role="doc-biblioref">Aigner et al. 2013</a>)</span>, the memory used by each processing unit was physically separated, leading to an n-fold increase in memory usage.</p>
<p>Other solvers, such as the one proposed in <span class="citation" data-cites="hyvarinen2012approaches manthey2011parallel">(<a href="#ref-hyvarinen2012approaches" role="doc-biblioref">Hyvarinen and Wintersteiger 2012</a>; <a href="#ref-manthey2011parallel" role="doc-biblioref">Manthey 2011</a>)</span>, used a more finer granularity in their parallelization approach where multiple cores exchange clauses to solve the problem; however, these methods were not scalable to a high number of cores and resulted in limited improvement. With regard to modern graphical processing unit (GPU) and field-programmable gate array (FPGA) computing, several solutions have been proposed <span class="citation" data-cites="10.1007/3-540-44614-1_50 707896 4555925 10.1145/1497561.1497576 10.1007/s10703-023-00432-z 11390_1234673 5547116 10.1007/978-3-030-72016-2_8">(<a href="#ref-10.1007/3-540-44614-1_50" role="doc-biblioref">Redekopp and Dandalis 2000</a>; <a href="#ref-707896" role="doc-biblioref">Zhong et al. 1998</a>; <a href="#ref-4555925" role="doc-biblioref">J. D. Davis et al. 2008</a>; <a href="#ref-10.1145/1497561.1497576" role="doc-biblioref">Gulati et al. 2009</a>; <a href="#ref-10.1007/s10703-023-00432-z" role="doc-biblioref">Osama, Wijs, and Biere 2023</a>, <a href="#ref-10.1007/978-3-030-72016-2_8" role="doc-biblioref">2021</a>; <a href="#ref-11390_1234673" role="doc-biblioref">Collevati, Dovier, and Formisano 2022</a>; <a href="#ref-5547116" role="doc-biblioref">Meyer et al. 2010</a>)</span>. However, some have not demonstrated promising results and while some show potential, discussions of these solvers are outside the focus of this thesis.</p>
<p>Despite all the developments in parallel computing and parallel algorithm designs, the transition from sequential to parallel solvers remains highly challenging, if not impossible, in some cases. Most solvers are originally designed for sequential execution; therefore, adapting them to parallel environments often requires a thorough understanding of the problem domain, algorithm design, and many core systems.</p>
<p>A number of works have shown that this problem can be overcome by improving performance without directly developing new solvers. Instead, existing solvers can be used and combined in a portfolio, selecting the appropriate solver(s) <span class="citation" data-cites="Kotthoff2014 satzilla kadiogluwin">(<a href="#ref-Kotthoff2014" role="doc-biblioref">Kotthoff 2014</a>; <a href="#ref-satzilla" role="doc-biblioref">Xu et al. 2008</a>; <a href="#ref-kadiogluwin" role="doc-biblioref">Kadıoglu, Malitsky, and Sellmann, n.d.</a>)</span>. In cases where multiple solvers are chosen, they can be run in a schedule, in parallel, or in combination with each other to achieve superior performance.</p>
<figure id="fig:nativealgselec" class="figure">
<div class="lrbox">
<p><img src="plots/as.png" style="width:90%" class="figure-img"></p>
</div>
<figcaption>
Algorithm Selection using ML models
</figcaption>
</figure>
</section>
<section id="algorithm-selection" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="algorithm-selection"><span class="header-section-number">3.2</span> Algorithm Selection</h2>
<p>Algorithm selection is a meta-algorithmic technique that was first introduced by John Rice <span class="citation" data-cites="Rice1976">(<a href="#ref-Rice1976" role="doc-biblioref">Rice 1976</a>)</span> in 1976. The algorithm selection problem is strategically choosing the most suitable algorithm from a set of candidates to solve a specific problem instance using the features and characteristics of the problem instances. This problem is closely related to general optimization theory, as both involve finding the best solution among a set of options <span class="citation" data-cites="Rice1976">(<a href="#ref-Rice1976" role="doc-biblioref">Rice 1976</a>)</span>. Algorithm selection is an important task in optimizing the performance of computationally expensive tasks, particularly those that can be translated into combinatorial problems <span class="citation" data-cites="Kotthoff2014">(<a href="#ref-Kotthoff2014" role="doc-biblioref">Kotthoff 2014</a>)</span>, NP-complete and NP-hard problems <span class="citation" data-cites="GCP 10.1109/CEC55065.2022.9870417">(<a href="#ref-GCP" role="doc-biblioref">Musliu and Schwengerer 2013</a>; <a href="#ref-10.1109/CEC55065.2022.9870417" role="doc-biblioref">Sitaru and Raschip 2022</a>)</span>.</p>
<p>During the last two decades, the algorithm selection problem has attracted significant attention from both researchers and practitioners as it is relevant in various domains, including high-performance computing <span class="citation" data-cites="FlorinaOpneMP">(<a href="#ref-FlorinaOpneMP" role="doc-biblioref">Ciorba et al. 2023</a>)</span>, sorting <span class="citation" data-cites="10.5120/ijca2016910726">(<a href="#ref-10.5120/ijca2016910726" role="doc-biblioref">Somshubra Majumdar 2016</a>)</span>, probabilistic inference <span class="citation" data-cites="sotingAS KOCAMAZ201394">(<a href="#ref-sotingAS" role="doc-biblioref">Guo and Hsu 2003</a>; <a href="#ref-KOCAMAZ201394" role="doc-biblioref">Kocamaz 2013</a>)</span>, software validation <span class="citation" data-cites="10.1007/s10515-020-00270-x">(<a href="#ref-10.1007/s10515-020-00270-x" role="doc-biblioref">Richter et al. 2020</a>)</span>, software verification <span class="citation" data-cites="9463528 10.1145/3637225">(<a href="#ref-9463528" role="doc-biblioref">Wang et al. 2021</a>; <a href="#ref-10.1145/3637225" role="doc-biblioref">Leeson and Dwyer 2024</a>)</span>, software package dependency management <span class="citation" data-cites="osti_2223030">(<a href="#ref-osti_2223030" role="doc-biblioref">Nichols et al. 2023</a>)</span> and data mining <span class="citation" data-cites="10.4108/ICST.SIMUTOOLS2009.5659 10.1145/3411564.3411646">(<a href="#ref-10.4108/ICST.SIMUTOOLS2009.5659" role="doc-biblioref">Ewald, Uhrmacher, and Saha 2010</a>; <a href="#ref-10.1145/3411564.3411646" role="doc-biblioref">Batista dos Santos and Merschmann 2020</a>)</span>. Algorithm selection is also applicable in the fields of meta-learning and automated machine learning (AutoML), where the goal is to build a meta-model that recommends the best machine learning algorithm, configurations and hyper-parameters for a given training task <span class="citation" data-cites="brazdil2022metalearning Vanschoren2019 hutter2019automated">(<a href="#ref-brazdil2022metalearning" role="doc-biblioref">Brazdil et al. 2022</a>; <a href="#ref-Vanschoren2019" role="doc-biblioref">Vanschoren 2019</a>; <a href="#ref-hutter2019automated" role="doc-biblioref">Hutter, Kotthoff, and Vanschoren 2019</a>)</span>. In algorithm selection problem, the search space is a discrete set of algorithms, while in problems such as the hyperparameter optimization (HPO) and the combination algorithm selection and hyperparameter optimization (CASH) problem <span class="citation" data-cites="10.1145/2487575.2487629">(<a href="#ref-10.1145/2487575.2487629" role="doc-biblioref">Thornton et al. 2013</a>)</span>, the search spaces are typically continuous or heterogeneous configuration spaces <span class="citation" data-cites="brazdil2022metalearning">(<a href="#ref-brazdil2022metalearning" role="doc-biblioref">Brazdil et al. 2022</a>)</span>.</p>
<p>Algorithm selection is sometimes known as portfolio-based algorithm selection in the literature <span class="citation" data-cites="10.5555/2898607.2898641 XuEtAl11">(<a href="#ref-10.5555/2898607.2898641" role="doc-biblioref">Xu, Hoos, and Leyton-Brown 2010</a>; <a href="#ref-XuEtAl11" role="doc-biblioref">Xu et al. 2011</a>)</span>, and is used in combination with automatic algorithm configuration. Algorithm Configuration is a specialized subset of algorithm selection <span class="citation" data-cites="10.1007/978-3-319-09584-4_4">(<a href="#ref-10.1007/978-3-319-09584-4_4" role="doc-biblioref">Hutter, López-Ibáñez, et al. 2014</a>)</span> in which algorithms with varying configuration parameters build a portfolio. The configuration parameters of these algorithms are dynamically adjusted based on the problem instance. This allows algorithms to adapt to the specifics of a problem, potentially improving their performance. This approach involves using different configurations of an algorithm to design a portfolio of solvers and choose the appropriate algorithm to solve problems. Focusing on the literature on algorithm configuration techniques is beyond the scope of this chapter.</p>
<p>A traditional approach to address algorithm selection is the "winner-take-all" or per-set algorithm selection strategy <span class="citation" data-cites="10.1162/evco_a_00242">(<a href="#ref-10.1162/evco_a_00242" role="doc-biblioref">Kerschke et al. 2019</a>)</span>, where different algorithms are evaluated based on their performance across a problem distribution, and the one with the lowest average runtime is chosen. However, this per-distribution selection often leads to the neglect of algorithms that may not perform well on average, but could excel in specific instances <span class="citation" data-cites="10.5555/1630659.1630927">(<a href="#ref-10.5555/1630659.1630927" role="doc-biblioref">Leyton-Brown et al. 2003</a>)</span>. Per-instance algorithm selection, however, has proven effective in numerous problem solving scenarios <span class="citation" data-cites="BISCHL201641">(<a href="#ref-BISCHL201641" role="doc-biblioref">Bischl et al. 2016</a>)</span>.</p>
<p>Instance-based selection of an effective algorithm is inherently complex, and evaluation of numerous algorithms against various performance criteria is needed, which can lead to significant computational demands. In addition, the abundance of algorithms designed to address different types of problem has underscored the importance of developing effective strategies for selecting the best algorithm for a given context. The field of algorithm selection has evolved significantly to address these challenges and there is a wide choice of algorithm selection techniques available in the literature.</p>
<p>One key component of per-instance algorithm selection is feature selection. In order to improve the design and selection of algorithms, measuring the difficulty of instances and identifying features of the instance that contribute to its complexity is a fundamental task <span class="citation" data-cites="SMITHMILES2012875 10.1007/978-3-319-32034-2_25">(<a href="#ref-SMITHMILES2012875" role="doc-biblioref">Smith-Miles and Lopes 2012</a>; <a href="#ref-10.1007/978-3-319-32034-2_25" role="doc-biblioref">Cárdenas-Montes 2016</a>)</span>. Different studies have concluded that problem instance features contribute distinctively to the performance of different solvers. <span class="citation" data-cites="10.1007/3-540-46135-3_37">(<a href="#ref-10.1007/3-540-46135-3_37" role="doc-biblioref">Leyton-Brown, Nudelman, and Shoham 2002</a>)</span> used statistical regression models to understand the empirical hardness of NP-hard problems, which is believed to help tailor algorithms based on the hardness of instances. <span class="citation" data-cites="10.1007/978-3-540-30201-8_33">(<a href="#ref-10.1007/978-3-540-30201-8_33" role="doc-biblioref">Nudelman et al., n.d.</a>)</span> also contributed to understanding the impact of the features of SAT instances on the difficulty of the problem. In short, the literature pertaining to the study of instance features strongly suggests that solvers need to be either designed to address a specific instance or carefully selected to solve the particular problem.</p>
<p>For various types of problem, numerous studies have focused on collecting and identifying features to aid in training performant algorithm selectors. In the domain of SAT, works such as <span class="citation" data-cites="10.1007/978-3-540-30201-8_33 satzilla HUTTER201479">(<a href="#ref-10.1007/978-3-540-30201-8_33" role="doc-biblioref">Nudelman et al., n.d.</a>; <a href="#ref-satzilla" role="doc-biblioref">Xu et al. 2008</a>; <a href="#ref-HUTTER201479" role="doc-biblioref">Hutter, Xu, et al. 2014</a>)</span> have made significant contributions by extracting features from the CNF formulas of SAT instances. More recently, <span class="citation" data-cites="shavit_et_al">(<a href="#ref-shavit_et_al" role="doc-biblioref">Shavit and Hoos 2024</a>)</span> revised the SATzilla feature extractor, showing notable performance improvements with the updated SAT features. In the field of AI planning, studies such as <span class="citation" data-cites="howe2000exploiting Fawcett_Vallati_Hutter_Hoffmann_Hoos_Leyton-Brown_2014 roberts2008makes cenamor2013learning">(<a href="#ref-howe2000exploiting" role="doc-biblioref">Howe et al. 2000</a>; <a href="#ref-Fawcett_Vallati_Hutter_Hoffmann_Hoos_Leyton-Brown_2014" role="doc-biblioref">Fawcett et al. 2014</a>; <a href="#ref-roberts2008makes" role="doc-biblioref">Roberts et al. 2008</a>; <a href="#ref-cenamor2013learning" role="doc-biblioref">Cenamor, De La Rosa, and Fernández 2013</a>)</span> have contributed by extracting features from the PDDL format of AI planning instances. Although most studies focus on instance features, some have also explored extracting algorithm-specific features and incorporating them into performance model training <span class="citation" data-cites="pmlr-v188-pulatov22a">(<a href="#ref-pmlr-v188-pulatov22a" role="doc-biblioref">Pulatov et al. 2022</a>)</span>. Algorithm selection using machine learning and statistical analysis is made possible through the extraction and utilization of these features.</p>
<p>Feature selection is only appropriate if its calculation time is considerably less than the time needed to run all the algorithms. <span class="citation" data-cites="Carchrae2005APPLYINGML">(<a href="#ref-Carchrae2005APPLYINGML" role="doc-biblioref">Carchrae and Beck 2005</a>)</span> explored low-knowledge techniques that focus only on observed performance improvement, demonstrating that effective algorithm selection does not always require deep domain knowledge and complex feature extractions and predictive models. In addition, in scenarios where traditional meta-features are hard to obtain, such as image segmentation tasks, verification-based approaches could be used <span class="citation" data-cites="10194439">(<a href="#ref-10194439" role="doc-biblioref">Lukac and Kameyama 2023</a>)</span>.</p>
<p>There is extensive literature on per-instance algorithm selection approaches, developed to resolve various NP-complete and NP-hard problems, including SAT, TSP, and other related challenges <span class="citation" data-cites="satzilla 10.1007/978-3-642-31612-8_18 10.1162/evco_a_00215 Kotthoff2014 10.1162/evco_a_00242">(<a href="#ref-satzilla" role="doc-biblioref">Xu et al. 2008</a>, <a href="#ref-10.1007/978-3-642-31612-8_18" role="doc-biblioref">2012</a>; <a href="#ref-10.1162/evco_a_00215" role="doc-biblioref">Kerschke et al. 2018</a>, <a href="#ref-10.1162/evco_a_00242" role="doc-biblioref">2019</a>; <a href="#ref-Kotthoff2014" role="doc-biblioref">Kotthoff 2014</a>)</span>. Some methods are offline, where solvers are selected before solving the problems (e.g., <span class="citation" data-cites="satzilla">(<a href="#ref-satzilla" role="doc-biblioref">Xu et al. 2008</a>)</span>), while others are online, where solvers are continuously selected during the solving process (e.g., <span class="citation" data-cites="arbelaez2009online">(<a href="#ref-arbelaez2009online" role="doc-biblioref">Arbelaez, Hamadi, and Sebag 2009</a>)</span>).</p>
<p>A large number of studies in the broader literature have examined machine learning-based approaches to tackle the algorithm selection problem, ranging from simple classifiers to complex ensemble approaches. These studies focus on using machine learning algorithms to learn the performance mapping from problem instances to algorithms by extracting features from instances <span class="citation" data-cites="Kotthoff2014">(<a href="#ref-Kotthoff2014" role="doc-biblioref">Kotthoff 2014</a>)</span>. To name a few, <span class="citation" data-cites="guo_learning-based_2005">(<a href="#ref-guo_learning-based_2005" role="doc-biblioref">Guo and Hsu 2005</a>)</span> has focused on training two classifiers to predict the appropriate exact and approximation algorithms to solve the most probable explanation (MPE) problems. Rule-based systems also play a role in the literature using rules or decision trees to assign algorithms to problem instances based on extracted features <span class="citation" data-cites="ali2006learning">(<a href="#ref-ali2006learning" role="doc-biblioref">Ali and Smith 2006</a>)</span>. <span class="citation" data-cites="NIPS2014_7fb8ceb3">(<a href="#ref-NIPS2014_7fb8ceb3" role="doc-biblioref">Lieder et al. 2014</a>)</span> considers algorithm selection as a special case of metareasoning and proposes a model for human cognitive strategy selection to solve the sorting problem.</p>
<p>In the ASLib paper, different regression and classification methods are also compared, with the results showing that the RandomForest regression is superior to other methods <span class="citation" data-cites="BISCHL201641">(<a href="#ref-BISCHL201641" role="doc-biblioref">Bischl et al. 2016</a>)</span>. Before the implementation of the ASLib data format and library, algorithm selection studies were scattered and many were unaware of each other, so comparing different approaches was challenging due to the absence of a standardized format. ASLib was proposed to standardize model training and to collect benchmarking data in a structured manner which facilitated comparisons <span class="citation" data-cites="BISCHL201641">(<a href="#ref-BISCHL201641" role="doc-biblioref">Bischl et al. 2016</a>)</span>. In response to the need for a fair comparison of different algorithm selection methods, the ICON Challenge on Algorithm Selection was held in 2015 and 2017 <span class="citation" data-cites="LINDAUER201986">(<a href="#ref-LINDAUER201986" role="doc-biblioref">M. Lindauer, van Rijn, and Kotthoff 2019</a>)</span>. In 2015, the Zilla system <span class="citation" data-cites="satzilla">(<a href="#ref-satzilla" role="doc-biblioref">Xu et al. 2008</a>)</span> was the winner among eight different methods. In the 2017 challenge, ASAP.v2 <span class="citation" data-cites="Gonard2019">(<a href="#ref-Gonard2019" role="doc-biblioref">Gonard, Schoenauer, and Sebag 2019</a>)</span> was the overall winner of eight other methods. The comparison in this competition was conducted using the ASLib format and library."</p>
<p>Other efforts exist which have not specifically focused on improving algorithm selector choices, but rather on making the decision-making process more intuitive or reducing the cost of performance model training. Some efforts have aimed to improve the transparency of algorithm selection through explainability methods. For example, <span class="citation" data-cites="explainability">(<a href="#ref-explainability" role="doc-biblioref">Visentin et al. 2024</a>)</span> employed iterative feature selection and SHAP analysis to explain selection decisions. Additionally, the cost of training algorithm selection models can be high due to the need to run candidate algorithms on a representative set of training instances. <span class="citation" data-cites="erdem_ku__2024">(<a href="#ref-erdem_ku__2024" role="doc-biblioref">Kuş et al. 2024</a>)</span> reduces training costs by selecting a subset of training instances using active learning, with timeout predictors and progressively increasing timeouts to further minimize costs. <span class="citation" data-cites="brighton2002advances">(<a href="#ref-brighton2002advances" role="doc-biblioref">Brighton and Mellish 2002</a>)</span> has also focused on instance selection which means focusing on choosing a representative set of instances for training, which can help identify the most suitable algorithm and improve algorithm selector efficiency.</p>
</section>
<section id="algorithm-portfolios-and-scheduling" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="algorithm-portfolios-and-scheduling"><span class="header-section-number">3.3</span> Algorithm Portfolios and Scheduling</h2>
<p>In response to the reality that no single algorithm can effectively address all types of problems, the concept of utilizing a portfolio emerged <span class="citation" data-cites="GOMES200143">(<a href="#ref-GOMES200143" role="doc-biblioref">C. Gomes and Selman 2001</a>)</span>. Drawing from the concept of risk diversification in finance, as discussed in <span class="citation" data-cites="Huberman1997">(<a href="#ref-Huberman1997" role="doc-biblioref">Huberman, Lukose, and Hogg 1997</a>)</span>, it is generally wiser to distribute investments across multiple options rather than concentrating on a single one.</p>
<p>Similarly, to optimize problem solving, an algorithm portfolio includes a diverse set of algorithms with complementary performance characteristics, ensuring that at least one will be effective in solving any given instance. These algorithms often have different probability distributions for runtimes. We can leverage their strengths by combining them into algorithm portfolio approaches to take advantage of differences in probability distributions to enhance overall efficiency as proposed by <span class="citation" data-cites="GOMES200143 Gomes1997AlgorithmPD">(<a href="#ref-GOMES200143" role="doc-biblioref">C. Gomes and Selman 2001</a>; <a href="#ref-Gomes1997AlgorithmPD" role="doc-biblioref">C. P. Gomes and Selman 1997</a>)</span>.</p>
<p>Subsequently, this portfolio can be leveraged through various methods to use the strengths of multiple algorithms and ultimately reduces risk <span class="citation" data-cites="GOMES200143 Huberman1997 Gomes1997AlgorithmPD yuri_malitsky__2014">(<a href="#ref-GOMES200143" role="doc-biblioref">C. Gomes and Selman 2001</a>; <a href="#ref-Huberman1997" role="doc-biblioref">Huberman, Lukose, and Hogg 1997</a>; <a href="#ref-Gomes1997AlgorithmPD" role="doc-biblioref">C. P. Gomes and Selman 1997</a>; <a href="#ref-yuri_malitsky__2014" role="doc-biblioref">Malitsky et al. 2014</a>)</span>. Different portfolio approaches have been proposed to effectively harness the capabilities of multiple complementary algorithms. An approach already discussed in this chapter is algorithm selection, where the objective is to select a single suitable algorithm per instance. Another approach, plain portfolio selection, includes some algorithms that can be executed in parallel on a multicore machine <span class="citation" data-cites="p3s flexfolio aspeed ppfolio wotzlawpfoliouzk">(<a href="#ref-p3s" role="doc-biblioref">Malitsky et al. 2012</a>; <a href="#ref-flexfolio" role="doc-biblioref">M. Lindauer, Bergdoll, and Hutter 2016</a>; <a href="#ref-aspeed" role="doc-biblioref">H. H. Hoos et al. 2015</a>; <a href="#ref-ppfolio" role="doc-biblioref">Roussel 2012</a>; <a href="#ref-wotzlawpfoliouzk" role="doc-biblioref">Wotzlaw et al. 2012</a>)</span> or sequentially on a single processor by splitting the available time between solvers <span class="citation" data-cites="3s lindauer2014algorithm flexfolio 10.5555/2540128.2540217 satzilla cphydra sunnycp hoos2014claspfolio2advancesalgorithm 10.5555/3013589.3013607">(<a href="#ref-3s" role="doc-biblioref">Kadioglu et al. 2011</a>; <a href="#ref-lindauer2014algorithm" role="doc-biblioref">T. M. Lindauer 2014</a>; <a href="#ref-flexfolio" role="doc-biblioref">M. Lindauer, Bergdoll, and Hutter 2016</a>; <a href="#ref-10.5555/2540128.2540217" role="doc-biblioref">Malitsky et al. 2013</a>; <a href="#ref-satzilla" role="doc-biblioref">Xu et al. 2008</a>; <a href="#ref-cphydra" role="doc-biblioref">O’Mahony et al. 2008</a>; <a href="#ref-sunnycp" role="doc-biblioref">Amadini, Gabbrielli, and Mauro 2018</a>; <a href="#ref-hoos2014claspfolio2advancesalgorithm" role="doc-biblioref">H. Hoos, Lindauer, and Schaub 2014</a>; <a href="#ref-10.5555/3013589.3013607" role="doc-biblioref">Cenamor, De La Rosa, and Fernández 2016</a>)</span>. In addition, numerous alternative approaches have been developed to enable algorithms in the portfolio to cooperate with each other, such as clause sharing, clause exchange, and search space splitting. Ultimately, these approaches outperform any individual algorithm.</p>
<p>In the plain sequential portfolio domain, over time, a vast body of literature has developed successful sequential portfolio solvers. In particular, 3S <span class="citation" data-cites="3s">(<a href="#ref-3s" role="doc-biblioref">Kadioglu et al. 2011</a>)</span> and CSHC <span class="citation" data-cites="10.5555/2540128.2540217">(<a href="#ref-10.5555/2540128.2540217" role="doc-biblioref">Malitsky et al. 2013</a>)</span> both secured gold medals in the 2011 and 2013 SAT competitions, respectively. SATZilla <span class="citation" data-cites="satzilla">(<a href="#ref-satzilla" role="doc-biblioref">Xu et al. 2008</a>)</span> won the SAT Challenge 2012, CPHydra <span class="citation" data-cites="cphydra">(<a href="#ref-cphydra" role="doc-biblioref">O’Mahony et al. 2008</a>)</span> was the winner of Intetnational Constraint Solver Competition 2008, and Sunny-CP won MiniZinc Challenge in 2015 <span class="citation" data-cites="sunnycp">(<a href="#ref-sunnycp" role="doc-biblioref">Amadini, Gabbrielli, and Mauro 2018</a>)</span>. In addition, Claspfolio <span class="citation" data-cites="hoos2014claspfolio2advancesalgorithm">(<a href="#ref-hoos2014claspfolio2advancesalgorithm" role="doc-biblioref">H. Hoos, Lindauer, and Schaub 2014</a>)</span> earned the gold medal in both the ASP 2009 and 2011 competitions, and IBaCOP2 <span class="citation" data-cites="10.5555/3013589.3013607">(<a href="#ref-10.5555/3013589.3013607" role="doc-biblioref">Cenamor, De La Rosa, and Fernández 2016</a>)</span> won the Sequential Satisficing Track in the 2014 International Planning Competition.</p>
<p>3S <span class="citation" data-cites="3s">(<a href="#ref-3s" role="doc-biblioref">Kadioglu et al. 2011</a>)</span> combines solver selection and scheduling. It trains a performance model using K-Nearest Neighbors (KNN) and improves the KNN approach with Distance-Based Weighting and Clustering-Based Adaptive Neighborhood Size. Additionally, they enhanced the model by integrating solver scheduling and testing various approaches such as static scheduling, dynamic scheduling, fixed-time scheduling, and semistatic scheduling. Semi-static scheduling performed best, where 90% of the time was allocated to the solver suggested by the KNN model, and 10% to a static solver schedule, which chose the top solvers averaged over all instances and allocated time statically.</p>
<p>CSHC <span class="citation" data-cites="10.5555/2540128.2540217">(<a href="#ref-10.5555/2540128.2540217" role="doc-biblioref">Malitsky et al. 2013</a>)</span> selects a portfolio of solvers using a classification method known as cost-sensitive hierarchical clustering and then sequentially allocates time to each solver. In short, the cost-sensitive hierarchical clustering method selects algorithms by grouping problem instances based on their features and the cost of misclassification. It starts with all instances in one cluster and splits them to maximize agreement on the best algorithm within each cluster. Clusters with too few instances are discarded, and merging is considered if it improves performance.</p>
<p>In SATZilla <span class="citation" data-cites="satzilla">(<a href="#ref-satzilla" role="doc-biblioref">Xu et al. 2008</a>)</span>, seven solvers are selected by manually analyzing competition results to identify algorithms that perform best on specific subsets of instances. An empirical hardness model, trained on instance features, is then used to select the most appropriate solver for each instance. Additionally, SATZilla employs presolvers, typically two, that run before the main solver, quickly resolving instances that are easy to solve. For harder instances which did not get resolved in the presolver phase, one solver is chosen from the seven based on the model’s predictions, and the remaining time is allocated to this solver based on its expected performance.</p>
<p>CPHydra <span class="citation" data-cites="cphydra">(<a href="#ref-cphydra" role="doc-biblioref">O’Mahony et al. 2008</a>)</span> is another sequential algorithm portfolio approach designed to solve constraint satisfaction problems using case-based reasoning (CBR). CBR is a lazy machine learning method in which no model is explicitly trained; instead, the selection is based on past cases and experiences. CPHydra uses syntactic features, such as the average and maximum domain size, and solver-specific features, including recorded search statistics, number of explored nodes, and runtime, which describe the problem instance. Subsequently, the KNN algorithm is employed to query the top k (with k set to 10) similar cases to the current problem instance to choose the dominated solvers. The available CPU time limit is then divided among multiple solvers, in contrast to approaches such as SATzilla, which rely on a single solver. This division is formulated as a small knapsack problem with the aim of maximizing the probability of finding a solution. The scheduling is computed to maximize the number of similar cases that can be solved using the assigned schedule.</p>
<p>Claspfolio <span class="citation" data-cites="10.1007/978-3-642-20895-9_40">(<a href="#ref-10.1007/978-3-642-20895-9_40" role="doc-biblioref">Gebser et al. 2011</a>)</span> considers multiple configurations of the clasp ASP solver and uses support vector regression (SVR) to select suitable solvers. Claspfolio is composed of four key parts: an ASP grounder, gringo; a lightweight clasp solver called claspre (which extracts features from the problem instance); a scoring mechanism that evaluates clasp configurations based on the extracted features; and finally, the configuration with the highest score is selected to solve the instance. There is no explicit scheduling in the original Claspfolio approach, but it is considered a sequential portfolio approach because it selects one solver configuration and runs it sequentially. <span class="citation" data-cites="hoos2014claspfolio2advancesalgorithm">(<a href="#ref-hoos2014claspfolio2advancesalgorithm" role="doc-biblioref">H. Hoos, Lindauer, and Schaub 2014</a>)</span> later introduced Claspfolio2, which includes a solver schedule based on a pre-solving method. This approach employs a timeout-minimal pre-solving schedule using ASPEED <span class="citation" data-cites="aspeed">(<a href="#ref-aspeed" role="doc-biblioref">H. H. Hoos et al. 2015</a>)</span>, where each solver is assigned a specific time budget to solve a given instance. Although ASPEED is capable of handling multicore scheduling, Claspfolio2 primarily focuses on sequential scheduling, maintaining the original approach’s emphasis on running solvers one after another.</p>
<p>IBaCOP <span class="citation" data-cites="10.5555/3013589.3013607">(<a href="#ref-10.5555/3013589.3013607" role="doc-biblioref">Cenamor, De La Rosa, and Fernández 2016</a>)</span> is a portfolio approach in the planning domain. It designs a portfolio by creating a per-instance configurable portfolio rather than using a fixed configuration. The design process involves selecting a set of planners (five in the experiments) to narrow down those likely to perform well for a given task. This selection is done using Pareto efficiency, choosing planners that offer a balance between different performance criteria without being dominated by others. The selected planners are then allocated a portion of time on a single processor. IBaCOP <span class="citation" data-cites="cenamor2014ibacop">(<a href="#ref-cenamor2014ibacop" role="doc-biblioref">Cenamor et al. 2014</a>)</span> was later developed based on the previous version, but more planners were included in the method, and a performance prediction model was trained instead of using Pareto efficiency for choosing the sub-portfolio, making the selection dynamic.</p>
<p>SNNAP <span class="citation" data-cites="collautti2013snnap">(<a href="#ref-collautti2013snnap" role="doc-biblioref">Collautti et al. 2013</a>)</span> is a KNN-based approach for solving SAT problems that combines supervised and unsupervised learning to create a solver portfolio. It uses random forests to predict the runtime of solvers on specific instances, and based on these predictions, it selects similar instances from the training set using KNN, choosing the top-performing solvers predicted to perform well on the given instance. The value of k is defined by the user, with the top three solvers being selected. SNNAP has been shown to outperform ISAC <span class="citation" data-cites="kadioglu2010isac">(<a href="#ref-kadioglu2010isac" role="doc-biblioref">Kadioglu et al. 2010</a>)</span>, a method for the configuration of algorithm based on instance that ultimately selects a single algorithm, in experiments. The available time is divided between the selected solvers, and they are run sequentially.</p>
<p>Sunny <span class="citation" data-cites="sunny">(<a href="#ref-sunny" role="doc-biblioref">Amadini, Gabbrielli, and Mauro 2014</a>)</span> is a portfolio designed to solve constraint satisfaction problems (CSP). It uses KNN to select a subset of training instances that are closest to the problem at hand. It then computes a schedule of solvers that solve the maximum number of instances within a specific time limit, allocating a portion of time to each solver to create a schedule. It also includes a backup solver to handle exceptional cases. Sunny-CP <span class="citation" data-cites="sunnycp">(<a href="#ref-sunnycp" role="doc-biblioref">Amadini, Gabbrielli, and Mauro 2018</a>)</span> is based on Sunny and extends its capabilities to handle both CSPs and constraint optimization problems (COPs). Sunny-CP includes an improved feature extraction tool compared to Sunny. Both Sunny and Sunny-CP are sequential portfolio designs.</p>
<p>AutoFolio <span class="citation" data-cites="lindauer2015autofolio">(<a href="#ref-lindauer2015autofolio" role="doc-biblioref">M. Lindauer et al. 2015</a>)</span> is another effort that integrates various algorithm and portfolio selection approaches. It is built on the claspfolio2 framework and employs a highly parametric framework for algorithm selection. AutoFolio is a general-purpose system, incorporating techniques from systems like 3S, ISAC, SATzilla, SNAPP as well as multiclass classification, pairwise classification, and various regression methods. Unlike many other systems, AutoFolio is not specific to any particular problem domain, aiming instead to harness the strengths of each algorithm selection approach it includes. However, it does not focus on parallel portfolios.</p>
<p>A recent sequential portfolio design is MedleySolver <span class="citation" data-cites="10.1007/978-3-030-80223-3_31">(<a href="#ref-10.1007/978-3-030-80223-3_31" role="doc-biblioref">Pimpalkhare et al. 2021</a>)</span>, which is designed to solve satisfiability modulo theories (SMT) problems. In this method, multiple solvers are selected based on the multi-armed bandit (MAB) framework and run sequentially. MAB models a situation where an agent must choose between multiple options, balancing the trade-off between exploring new solvers and exploiting the best-known solvers for the highest reward. MedleySolver essentially provides an ordering for a sequence of SMT solvers and splits available time between solvers.</p>
<p>In the domain of parallel portfolio solvers, the Plain Parallel Portfolio (PPP) approach involves running multiple solvers on same instance in parallel, leveraging multi-core shared memory architectures <span class="citation" data-cites="conf/sat/AignerBKNP13">(<a href="#ref-conf/sat/AignerBKNP13" role="doc-biblioref">Aigner et al. 2013</a>)</span>. In this approach, sequential solvers are treated as "black boxes", they do not share any information with each other, and as soon as any solver resolves the instance, the entire process stops <span class="citation" data-cites="conf/sat/AignerBKNP13 Marius2015">(<a href="#ref-conf/sat/AignerBKNP13" role="doc-biblioref">Aigner et al. 2013</a>; <a href="#ref-Marius2015" role="doc-biblioref">M. Lindauer, Hoos, and Hutter 2015</a>)</span>. Some PPP methods are static, where the sub-portfolios are selected to run on all problems and are not instance-based. Notable examples of static PPP solvers in the SAT domain include ManySAT <span class="citation" data-cites="Hamadi2009">(<a href="#ref-Hamadi2009" role="doc-biblioref">Hamadi, Jabbour, and Sais 2009</a>)</span>, ppfolio <span class="citation" data-cites="ppfolio">(<a href="#ref-ppfolio" role="doc-biblioref">Roussel 2012</a>)</span>, pfolioUZK <span class="citation" data-cites="wotzlawpfoliouzk">(<a href="#ref-wotzlawpfoliouzk" role="doc-biblioref">Wotzlaw et al. 2012</a>)</span>, with ppfolio excelling in the 2011 SAT Competition. The PPP approach typically selects the top solvers that consistently outperform others on average. This approach has also been used in methods such as SATZilla, where a presolving phase, as mentioned above, is employed <span class="citation" data-cites="satzilla">(<a href="#ref-satzilla" role="doc-biblioref">Xu et al. 2008</a>)</span>. However, this strategy often overlooks solvers that, while less dominant overall, may significantly outperform the top solvers in specific instances.</p>
<p>To address these limitations, more innovative approaches, such as P3S <span class="citation" data-cites="p3s">(<a href="#ref-p3s" role="doc-biblioref">Malitsky et al. 2012</a>)</span>, have been introduced. P3S is a parallel version of 3S <span class="citation" data-cites="3s">(<a href="#ref-3s" role="doc-biblioref">Kadioglu et al. 2011</a>)</span> and participated in the SAT Challenge 2012. It uses the same method as 3S but operates in parallel. ASPEED <span class="citation" data-cites="aspeed">(<a href="#ref-aspeed" role="doc-biblioref">H. H. Hoos et al. 2015</a>)</span>, a static ASP technique, defines a fixed schedule for multiple solvers to run in parallel, solving this scheduling problem using answer set programming. Sunny-cp2 <span class="citation" data-cites="sunnycp2">(<a href="#ref-sunnycp2" role="doc-biblioref">Amadini, Gabbrielli, and Mauro 2015</a>)</span> is another approach, a parallel version of Sunny-cp, designed for the parallel execution of constraint satisfaction and constraint optimization solvers. We will discuss these approaches in more detail in Chapter 4, where we introduce another approach in this field that surpasses the options currently available in the literature.</p>
<p>ArvandHerd <span class="citation" data-cites="10.5555/3007337.3007474">(<a href="#ref-10.5555/3007337.3007474" role="doc-biblioref">Valenzano et al. 2012</a>)</span> is another example of parallel portfolio design, but in planning problems. This method won tracks in the 2011 Planning Competition. The portfolio includes multiple configurations of two different planners. Typically, on three cores, two cores are dedicated to running multiple configurations of the Arvand solver, while one core is allocated to LAMA-2008 solver configurations. The process starts with one configuration, and if that configuration exhausts the memory, the planner restarts with another configuration.</p>
<p>Although there have been many studies on plain portfolio designs, no plain portfolio solvers have been accepted into the SAT competition since 2020 <span class="citation" data-cites="FROLEYKS2021103572">(<a href="#ref-FROLEYKS2021103572" role="doc-biblioref">Froleyks et al. 2021</a>)</span>. Prior to 2020, and since the SAT Competition 2016, plain portfolio solvers had the opportunity to enter the No Limit track where submitting the source code was not required. Before 2016, they were accepted as regular solvers, which is why we only have gold medalists and winning plain portfolio approaches related to competitions before 2016. Cooperative portfolio solvers, on the other hand, have been accepted in all tracks, especially in the parallel track of the SAT competition. In this portfolio approach, solvers can communicate, share learned clauses, or split search spaces to improve efficiency and performance.</p>
<p>For example, PRS-parallel, a parallel portfolio solver capable of running in distributed environments, supports clause sharing and won the parallel track of the 2023 SAT Competition <span class="citation" data-cites="sat2023">(<a href="#ref-sat2023" role="doc-biblioref">Tomas Balyo et al. 2023</a>)</span>. PaKis, the parallel portfolio solver that won the parallel track of the 2021 SAT Competition, relies on different configurations of the Kissat solver but does not support information sharing between solvers <span class="citation" data-cites="sat2021">(<a href="#ref-sat2021" role="doc-biblioref">Tomas Balyo et al. 2021</a>)</span>. There is a vast body of literature on cooperative portfolios, which is beyond the scope of this chapter.</p>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-conf/sat/AignerBKNP13" class="csl-entry" role="listitem">
Aigner, Martin, Armin Biere, Christoph M. Kirsch, Aina Niemetz, and Mathias Preiner. 2013. <span>“Analysis of Portfolio-Style Parallel <span>SAT</span> Solving on Current Multi-Core Architectures.”</span> In <em><span>POS-13.</span> Fourth Pragmatics of <span>SAT</span> Workshop, a Workshop of the <span>SAT</span> 2013 Conference, July 7, 2013, Helsinki, Finland</em>, edited by Daniel Le Berre, 29:28–40. EPiC Series in Computing. EasyChair. <a href="https://doi.org/10.29007/73N4">https://doi.org/10.29007/73N4</a>.
</div>
<div id="ref-ali2006learning" class="csl-entry" role="listitem">
Ali, Shawkat, and Kate A Smith. 2006. <span>“On Learning Algorithm Selection for Classification.”</span> <em>Applied Soft Computing</em> 6 (2): 119–38.
</div>
<div id="ref-sunny" class="csl-entry" role="listitem">
Amadini, Roberto, Maurizio Gabbrielli, and Jacopo Mauro. 2014. <span>“<span>SUNNY:</span> A Lazy Portfolio Approach for Constraint Solving.”</span> <em>Theory Pract. Log. Program.</em> 14 (4-5): 509–24. <a href="https://doi.org/10.1017/S1471068414000179">https://doi.org/10.1017/S1471068414000179</a>.
</div>
<div id="ref-sunnycp2" class="csl-entry" role="listitem">
———. 2015. <span>“<span class="nocase">A Multicore Tool for Constraint Solving</span>.”</span> In <em>Proceedings of the 24th International Conference on Artificial Intelligence</em>, 232–38.
</div>
<div id="ref-sunnycp" class="csl-entry" role="listitem">
———. 2018. <span>“SUNNY-CP and the MiniZinc Challenge.”</span> <em>Theory and Practice of Logic Programming</em> 18 (1): 81–96. <a href="https://doi.org/10.1017/S1471068417000205">https://doi.org/10.1017/S1471068417000205</a>.
</div>
<div id="ref-arbelaez2009online" class="csl-entry" role="listitem">
Arbelaez, Alejandro, Youssef Hamadi, and Michele Sebag. 2009. <span>“<span class="nocase">Online heuristic selection in constraint programming</span>.”</span>
</div>
<div id="ref-sat2021" class="csl-entry" role="listitem">
Balyo, Tomas, Nils Froleyks, Marijn Heule, Markus Iser, Matti Järvisalo, and Martin Suda, eds. 2021. <em>Proceedings of SAT Competition 2021: Solver and Benchmark Descriptions</em>. Anthology or special issue. Department of Computer Science Report Series b. Department of Computer Science Report Series B. <a href="http://hdl.handle.net/10138/333647">http://hdl.handle.net/10138/333647</a>.
</div>
<div id="ref-sat2023" class="csl-entry" role="listitem">
Balyo, Tomas, Marijn Heule, Markus Iser, Matti Järvisalo, and Martin Suda, eds. 2023. <em>Proceedings of SAT Competition 2023: Solver, Benchmark and Proof Checker Descriptions</em>. Anthology or special issue. Department of Computer Science, Helsinki Institute for Information Technology, Constraint Reasoning; Optimization research group / Matti Järvisalo.
</div>
<div id="ref-balyo_sat_2017" class="csl-entry" role="listitem">
Balyo, Tomáš, Marijn J H Heule, and Matti Järvisalo. 2017. <span>“<span>SAT</span> <span>Competition</span> 2017 <span>Solver</span> and <span>Benchmark</span> <span>Descriptions</span>.”</span> <em>Proceedings of SAT COMPETITION 2017</em>, 14–15.
</div>
<div id="ref-10.1145/3411564.3411646" class="csl-entry" role="listitem">
Batista dos Santos, Vânia, and Luiz Henrique de Campos Merschmann. 2020. <span>“Metalearning Applied to Multi-Label Text Classification.”</span> In <em>Proceedings of the XVI Brazilian Symposium on Information Systems</em>. SBSI ’20. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/3411564.3411646">https://doi.org/10.1145/3411564.3411646</a>.
</div>
<div id="ref-plingeling" class="csl-entry" role="listitem">
Biere, Armin. 2012. <span>“<span class="nocase">Lingeling and friends entering the SAT challenge 2012</span>.”</span> <em>Department of Computer Science Series of Publications B</em>, January, 33–34.
</div>
<div id="ref-Biere2013LingelingPA" class="csl-entry" role="listitem">
———. 2013. <span>“<span class="nocase">Lingeling, Plingeling and Treengeling Entering the SAT Competition 2013</span>.”</span> In. <a href="https://api.semanticscholar.org/CorpusID:972178">https://api.semanticscholar.org/CorpusID:972178</a>.
</div>
<div id="ref-biere2009conflict" class="csl-entry" role="listitem">
Biere, Armin, Marijn Heule, Hans van Maaren, and Toby Walsh. 2009. <span>“Conflict-Driven Clause Learning Sat Solvers.”</span> <em>Handbook of Satisfiability, Frontiers in Artificial Intelligence and Applications</em>, 131–53.
</div>
<div id="ref-series/faia/336" class="csl-entry" role="listitem">
———, eds. 2021. <em>Handbook of Satisfiability - Second Edition</em>. Vol. 336. Frontiers in Artificial Intelligence and Applications. <span>IOS</span> Press. <a href="https://doi.org/10.3233/FAIA336">https://doi.org/10.3233/FAIA336</a>.
</div>
<div id="ref-BISCHL201641" class="csl-entry" role="listitem">
Bischl, Bernd, Pascal Kerschke, Lars Kotthoff, Marius Lindauer, Yuri Malitsky, Alexandre Fréchette, Holger Hoos, et al. 2016. <span>“<span>ASlib</span>: A Benchmark Library for Algorithm Selection.”</span> <em>Artificial Intelligence</em> 237: 41–58.
</div>
<div id="ref-brazdil2022metalearning" class="csl-entry" role="listitem">
Brazdil, P., J. N. van Rijn, C. Soares, and J. Vanschoren. 2022. <em>Metalearning: Applications to Automated Machine Learning and Data Mining</em>. Cognitive Technologies. Springer International Publishing. <a href="https://books.google.com/books?id=zDcOzgEACAAJ">https://books.google.com/books?id=zDcOzgEACAAJ</a>.
</div>
<div id="ref-brighton2002advances" class="csl-entry" role="listitem">
Brighton, Henry, and Chris Mellish. 2002. <span>“Advances in Instance Selection for Instance-Based Learning Algorithms.”</span> <em>Data Mining and Knowledge Discovery</em> 6: 153–72.
</div>
<div id="ref-Carchrae2005APPLYINGML" class="csl-entry" role="listitem">
Carchrae, Tom, and J. Christopher Beck. 2005. <span>“<span class="nocase">Applying Machine Learning to Low-Knowledge Control of Optimization Algorithms</span>.”</span> <em>Computational Intelligence</em> 21. <a href="https://api.semanticscholar.org/CorpusID:7953876">https://api.semanticscholar.org/CorpusID:7953876</a>.
</div>
<div id="ref-10.1007/978-3-319-32034-2_25" class="csl-entry" role="listitem">
Cárdenas-Montes, Miguel. 2016. <span>“<span class="nocase">Evaluating the Difficulty of Instances of the Travelling Salesman Problem in the Nearby of the Optimal Solution Based on Random Walk Exploration</span>.”</span> In <em>Hybrid Artificial Intelligent Systems</em>, edited by Francisco Martínez-Álvarez, Alicia Troncoso, Héctor Quintián, and Emilio Corchado, 299–310. Cham: Springer International Publishing.
</div>
<div id="ref-cenamor2013learning" class="csl-entry" role="listitem">
Cenamor, Isabel, Tomás De La Rosa, and Fernando Fernández. 2013. <span>“Learning Predictive Models to Configure Planning Portfolios.”</span> In <em>Proceedings of the 4th Workshop on Planning and Learning (ICAPS-PAL 2013)</em>, 14–22. Citeseer.
</div>
<div id="ref-10.5555/3013589.3013607" class="csl-entry" role="listitem">
———. 2016. <span>“<span class="nocase">The IBaCoP planning system: instance-based configured portfolios</span>.”</span> <em>J. Artif. Int. Res.</em> 56 (1): 657–91.
</div>
<div id="ref-cenamor2014ibacop" class="csl-entry" role="listitem">
Cenamor, Isabel, Tomás de la Rosa, Fernando Fernández, et al. 2014. <span>“<span class="nocase">IBACOP and IBACOP2 planner</span>.”</span> <em>IPC 2014 Planner Abstracts</em>, 35–38.
</div>
<div id="ref-FlorinaOpneMP" class="csl-entry" role="listitem">
Ciorba, Florina M., Ali Mohammed, Jonas H. Müller Korndörfer, and Ahmed Eleliemy. 2023. <span>“<span class="nocase">Automated Scheduling Algorithm Selection in OpenMP</span>.”</span> In <em>2023 22nd International Symposium on Parallel and Distributed Computing (ISPDC)</em>, 106–9. <a href="https://doi.org/10.1109/ISPDC59212.2023.00025">https://doi.org/10.1109/ISPDC59212.2023.00025</a>.
</div>
<div id="ref-collautti2013snnap" class="csl-entry" role="listitem">
Collautti, Marco, Yuri Malitsky, Deepak Mehta, and Barry O’Sullivan. 2013. <span>“<span class="nocase">SNNAP: Solver-based nearest neighbor for algorithm portfolios</span>.”</span> In <em>Machine Learning and Knowledge Discovery in Databases: European Conference, ECML PKDD 2013, Prague, Czech Republic, September 23-27, 2013, Proceedings, Part III 13</em>, 435–50. Springer.
</div>
<div id="ref-11390_1234673" class="csl-entry" role="listitem">
Collevati, M., Agostino Dovier, and A. Formisano. 2022. <span>“<span class="nocase">GPU Parallelism for SAT Solving Heuristics</span>.”</span> CEUR-WS.
</div>
<div id="ref-4555925" class="csl-entry" role="listitem">
Davis, John D., Zhangxi Tan, Fang Yu, and Lintao Zhang. 2008. <span>“A Practical Reconfigurable Hardware Accelerator for Boolean Satisfiability Solvers.”</span> In <em>2008 45th ACM/IEEE Design Automation Conference</em>, 780–85. <a href="https://doi.org/10.1145/1391469.1391669">https://doi.org/10.1145/1391469.1391669</a>.
</div>
<div id="ref-10.1145/368273.368557" class="csl-entry" role="listitem">
Davis, Martin, George Logemann, and Donald Loveland. 1962. <span>“A Machine Program for Theorem-Proving.”</span> <em>Commun. ACM</em> 5 (7): 394–97. <a href="https://doi.org/10.1145/368273.368557">https://doi.org/10.1145/368273.368557</a>.
</div>
<div id="ref-10.4108/ICST.SIMUTOOLS2009.5659" class="csl-entry" role="listitem">
Ewald, Roland, Adelinde M. Uhrmacher, and Kaustav Saha. 2010. <span>“Data Mining for Simulation Algorithm Selection.”</span> In. ICST. <a href="https://doi.org/10.4108/ICST.SIMUTOOLS2009.5659">https://doi.org/10.4108/ICST.SIMUTOOLS2009.5659</a>.
</div>
<div id="ref-Fawcett_Vallati_Hutter_Hoffmann_Hoos_Leyton-Brown_2014" class="csl-entry" role="listitem">
Fawcett, Chris, Mauro Vallati, Frank Hutter, Jörg Hoffmann, Holger Hoos, and Kevin Leyton-Brown. 2014. <span>“<span class="nocase">Improved Features for Runtime Prediction of Domain-Independent Planners</span>.”</span> <em>Proceedings of the International Conference on Automated Planning and Scheduling</em> 24 (1): 355–59. <a href="https://doi.org/10.1609/icaps.v24i1.13680">https://doi.org/10.1609/icaps.v24i1.13680</a>.
</div>
<div id="ref-FROLEYKS2021103572" class="csl-entry" role="listitem">
Froleyks, Nils, Marijn Heule, Markus Iser, Matti Järvisalo, and Martin Suda. 2021. <span>“<span>SAT Competition 2020</span>.”</span> <em>Artificial Intelligence</em> 301: 103572. https://doi.org/<a href="https://doi.org/10.1016/j.artint.2021.103572">https://doi.org/10.1016/j.artint.2021.103572</a>.
</div>
<div id="ref-10.1007/978-3-642-20895-9_40" class="csl-entry" role="listitem">
Gebser, Martin, Roland Kaminski, Benjamin Kaufmann, Torsten Schaub, Marius Thomas Schneider, and Stefan Ziller. 2011. <span>“<span class="nocase">A Portfolio Solver for Answer Set Programming: Preliminary Report</span>.”</span> In <em>Logic Programming and Nonmonotonic Reasoning</em>, edited by James P. Delgrande and Wolfgang Faber, 352–57. Berlin, Heidelberg: Springer Berlin Heidelberg.
</div>
<div id="ref-GEBSER_2019" class="csl-entry" role="listitem">
GEBSER, MARTIN, MARCO MARATEA, and FRANCESCO RICCA. 2019. <span>“<span class="nocase">The Seventh Answer Set Programming Competition: Design and Results</span>.”</span> <em>Theory and Practice of Logic Programming</em> 20 (2): 176–204. <a href="https://doi.org/10.1017/s1471068419000061">https://doi.org/10.1017/s1471068419000061</a>.
</div>
<div id="ref-journals/jsat/GilFS09" class="csl-entry" role="listitem">
Gil, Luı́s, Paulo F. Flores, and Luı́s Miguel Silveira. 2009. <span>“<span class="nocase">PMSat: a parallel version of MiniSAT</span>.”</span> <em>J. Satisf. Boolean Model. Comput.</em> 6 (1-3): 71–98. <a href="https://doi.org/10.3233/SAT190063">https://doi.org/10.3233/SAT190063</a>.
</div>
<div id="ref-Gomes1997AlgorithmPD" class="csl-entry" role="listitem">
Gomes, Carla Pedro, and Bart Selman. 1997. <span>“Algorithm Portfolio Design: Theory Vs. Practice.”</span> <em>ArXiv</em> abs/1302.1541. <a href="https://api.semanticscholar.org/CorpusID:8512615">https://api.semanticscholar.org/CorpusID:8512615</a>.
</div>
<div id="ref-GOMES200143" class="csl-entry" role="listitem">
Gomes, Carla, and Bart Selman. 2001. <span>“Algorithm Portfolios.”</span> <em>Artificial Intelligence</em> 126: 43–62.
</div>
<div id="ref-Gonard2019" class="csl-entry" role="listitem">
Gonard, François, Marc Schoenauer, and Michèle Sebag. 2019. <span>“<span class="nocase">Algorithm Selector and Prescheduler in the ICON Challenge</span>.”</span> In <em>Bioinspired Heuristics for Optimization</em>, 203–19. Springer International Publishing.
</div>
<div id="ref-10.1145/1497561.1497576" class="csl-entry" role="listitem">
Gulati, Kanupriya, Suganth Paul, Sunil P. Khatri, Srinivas Patil, and Abhijit Jas. 2009. <span>“<span class="nocase">FPGA-based hardware acceleration for Boolean satisfiability</span>.”</span> <em>ACM Trans. Des. Autom. Electron. Syst.</em> 14 (2). <a href="https://doi.org/10.1145/1497561.1497576">https://doi.org/10.1145/1497561.1497576</a>.
</div>
<div id="ref-sotingAS" class="csl-entry" role="listitem">
Guo, Haipeng, and William H. Hsu. 2003. <span>“Algorithm Selection for Sorting and Probabilistic Inference: A Machine Learning-Based Approach.”</span> PhD thesis, USA: Kansas State University.
</div>
<div id="ref-guo_learning-based_2005" class="csl-entry" role="listitem">
———. 2005. <span>“A <span>Learning</span>-<span>Based</span> <span>Algorithm</span> <span>Selection</span> <span>Meta</span>-<span>Reasoner</span> for the <span>Real</span>-<span>Time</span> <span>MPE</span> <span>Problem</span>.”</span> In <em><span>AI</span> 2004: <span>Advances</span> in <span>Artificial</span> <span>Intelligence</span></em>, edited by Geoffrey I. Webb and Xinghuo Yu, 307–18. Berlin, Heidelberg: Springer. <a href="https://doi.org/10.1007/978-3-540-30549-1_28">https://doi.org/10.1007/978-3-540-30549-1_28</a>.
</div>
<div id="ref-Hamadi2009" class="csl-entry" role="listitem">
Hamadi, Youssef, Said Jabbour, and Lakhdar Sais. 2009. <span>“<span class="nocase">ManySAT: a Parallel SAT Solver</span>.”</span> <em>Journal on Satisfiability, Boolean Modeling and Computation</em>. <a href="https://doi.org/10.3233/sat190070">https://doi.org/10.3233/sat190070</a>.
</div>
<div id="ref-10.1007/978-3-642-16242-8_37" class="csl-entry" role="listitem">
Hölldobler, Steffen, Norbert Manthey, and Ari Saptawijaya. 2010. <span>“<span>Improving Resource-Unaware SAT Solvers</span>.”</span> In <em>Logic for Programming, Artificial Intelligence, and Reasoning</em>, edited by Christian G. Fermüller and Andrei Voronkov, 519–34. Berlin, Heidelberg: Springer Berlin Heidelberg.
</div>
<div id="ref-holldobler_short_2011" class="csl-entry" role="listitem">
Hölldobler, Steffen, Norbert Manthey, Van Hau Nguyen, Julian Stecklina, and Peter Steinke. 2011. <span>“<span class="nocase">A short overview on modern parallel <span>SAT</span>-solvers</span>.”</span> <em>ICACSIS 2011 - 2011 International Conference on Advanced Computer Science and Information Systems, Proceedings</em>, no. January: 201–6.
</div>
<div id="ref-aspeed" class="csl-entry" role="listitem">
Hoos, Holger H., Roland Kaminski, Marius Thomas Lindauer, and Torsten Schaub. 2015. <span>“<span class="nocase">aspeed: Solver scheduling via answer set programming</span>.”</span> <em><span>TPLP</span></em> 15 (1): 117–42.
</div>
<div id="ref-hoos2014claspfolio2advancesalgorithm" class="csl-entry" role="listitem">
Hoos, Holger, Marius Lindauer, and Torsten Schaub. 2014. <span>“Claspfolio 2: Advances in Algorithm Selection for Answer Set Programming.”</span> <a href="https://arxiv.org/abs/1405.1520">https://arxiv.org/abs/1405.1520</a>.
</div>
<div id="ref-howe2000exploiting" class="csl-entry" role="listitem">
Howe, Adele E, Eric Dahlman, Christopher Hansen, Michael Scheetz, and Anneliese Von Mayrhauser. 2000. <span>“Exploiting Competitive Planner Performance.”</span> In <em>Recent Advances in AI Planning: 5th European Conference on Planning, ECP’99, Durham, UK, September 8-10, 1999. Proceedings 5</em>, 62–72. Springer.
</div>
<div id="ref-Huberman1997" class="csl-entry" role="listitem">
Huberman, Bernardo A., Rajan M. Lukose, and Tad Hogg. 1997. <span>“<span class="nocase">An economics approach to hard computational problems</span>.”</span> <em>Science</em> 275 (5296): 51–54. <a href="https://doi.org/10.1126/science.275.5296.51">https://doi.org/10.1126/science.275.5296.51</a>.
</div>
<div id="ref-hutter2019automated" class="csl-entry" role="listitem">
Hutter, Frank, Lars Kotthoff, and Joaquin Vanschoren, eds. 2019. <em>Automated Machine Learning - Methods, Systems, Challenges</em>. Springer.
</div>
<div id="ref-10.1007/978-3-319-09584-4_4" class="csl-entry" role="listitem">
Hutter, Frank, Manuel López-Ibáñez, Chris Fawcett, Marius Lindauer, Holger H. Hoos, Kevin Leyton-Brown, and Thomas Stützle. 2014. <span>“<span class="nocase">AClib: A Benchmark Library for Algorithm Configuration</span>.”</span> In <em>Learning and Intelligent Optimization</em>, edited by Panos M. Pardalos, Mauricio G. C. Resende, Chrysafis Vogiatzis, and Jose L. Walteros, 36–40. Cham: Springer International Publishing.
</div>
<div id="ref-HUTTER201479" class="csl-entry" role="listitem">
Hutter, Frank, Lin Xu, Holger H. Hoos, and Kevin Leyton-Brown. 2014. <span>“Algorithm Runtime Prediction: Methods &amp; Evaluation.”</span> <em>Artificial Intelligence</em> 206: 79–111. https://doi.org/<a href="https://doi.org/10.1016/j.artint.2013.10.003">https://doi.org/10.1016/j.artint.2013.10.003</a>.
</div>
<div id="ref-hyvarinen2012approaches" class="csl-entry" role="listitem">
Hyvarinen, Antti E. J., and Christoph M. Wintersteiger. 2012. <span>“<span class="nocase">Approaches for Multi-Core Propagation in Clause Learning Satisfiability Solvers</span>.”</span> MSR-TR-2012-47. <a href="https://www.microsoft.com/en-us/research/publication/approaches-for-multi-core-propagation-in-clause-learning-satisfiability-solvers/">https://www.microsoft.com/en-us/research/publication/approaches-for-multi-core-propagation-in-clause-learning-satisfiability-solvers/</a>.
</div>
<div id="ref-10.1007/978-3-540-85110-3_11" class="csl-entry" role="listitem">
Hyvärinen, Antti E. J., Tommi Junttila, and Ilkka Niemelä. 2008. <span>“Strategies for Solving <span>SAT</span> in Grids by Randomized Search.”</span> In <em>Intelligent Computer Mathematics</em>, edited by Serge Autexier, John Campbell, Julio Rubio, Volker Sorge, Masakazu Suzuki, and Freek Wiedijk, 125–40. Berlin, Heidelberg: Springer Berlin Heidelberg.
</div>
<div id="ref-10.1007/978-3-642-16242-8_27" class="csl-entry" role="listitem">
———. 2010. <span>“<span class="nocase">Partitioning SAT Instances for Distributed Solving</span>.”</span> In <em>Logic for Programming, Artificial Intelligence, and Reasoning</em>, edited by Christian G. Fermüller and Andrei Voronkov, 372–86. Berlin, Heidelberg: Springer Berlin Heidelberg.
</div>
<div id="ref-3s" class="csl-entry" role="listitem">
Kadioglu, Serdar, Yuri Malitsky, Ashish Sabharwal, Horst Samulowitz, and Meinolf Sellmann. 2011. <span>“<span class="nocase">Algorithm selection and scheduling</span>.”</span> <em>Lecture Notes in Computer Science (Including Subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)</em> 6876 LNCS: 454–69. <a href="https://doi.org/10.1007/978-3-642-23786-7_35">https://doi.org/10.1007/978-3-642-23786-7_35</a>.
</div>
<div id="ref-kadioglu2010isac" class="csl-entry" role="listitem">
Kadioglu, Serdar, Yuri Malitsky, Meinolf Sellmann, and Kevin Tierney. 2010. <span>“ISAC–Instance-Specific Algorithm Configuration.”</span> In <em>ECAI 2010</em>, 751–56. IOS Press.
</div>
<div id="ref-kadiogluwin" class="csl-entry" role="listitem">
Kadıoglu, Serdar, Yuri Malitsky, and Meinolf Sellmann. n.d. <span>“<span class="nocase">How to Win Gold at a SAT Competition Without Writing a SAT Solver</span>.”</span>
</div>
<div id="ref-Karp1972" class="csl-entry" role="listitem">
Karp, Richard M. 1972. <span>“Reducibility Among Combinatorial Problems.”</span> In <em>Complexity of Computer Computations: Proceedings of a Symposium on the Complexity of Computer Computations, Held March 20–22, 1972, at the IBM Thomas j. Watson Research Center, Yorktown Heights, New York, and Sponsored by the Office of Naval Research, Mathematics Program, IBM World Trade Corporation, and the IBM Research Mathematical Sciences Department</em>, edited by Raymond E. Miller, James W. Thatcher, and Jean D. Bohlinger, 85–103. Boston, MA: Springer US. <a href="https://doi.org/10.1007/978-1-4684-2001-2_9">https://doi.org/10.1007/978-1-4684-2001-2_9</a>.
</div>
<div id="ref-10.1162/evco_a_00242" class="csl-entry" role="listitem">
Kerschke, Pascal, Holger H. Hoos, Frank Neumann, and Heike Trautmann. 2019. <span>“<span class="nocase">Automated Algorithm Selection: Survey and Perspectives</span>.”</span> <em>Evolutionary Computation</em> 27 (1): 3–45. <a href="https://doi.org/10.1162/evco_a_00242">https://doi.org/10.1162/evco_a_00242</a>.
</div>
<div id="ref-10.1162/evco_a_00215" class="csl-entry" role="listitem">
Kerschke, Pascal, Lars Kotthoff, Jakob Bossek, Holger H. Hoos, and Heike Trautmann. 2018. <span>“<span class="nocase">Leveraging TSP Solver Complementarity through Machine Learning</span>.”</span> <em>Evolutionary Computation</em> 26 (4): 597–620. <a href="https://doi.org/10.1162/evco_a_00215">https://doi.org/10.1162/evco_a_00215</a>.
</div>
<div id="ref-KOCAMAZ201394" class="csl-entry" role="listitem">
Kocamaz, Uğur Erkin. 2013. <span>“Increasing the Efficiency of Quicksort Using a Neural Network Based Algorithm Selection Model.”</span> <em>Information Sciences</em> 229: 94–105. https://doi.org/<a href="https://doi.org/10.1016/j.ins.2012.11.014">https://doi.org/10.1016/j.ins.2012.11.014</a>.
</div>
<div id="ref-Kotthoff2014" class="csl-entry" role="listitem">
Kotthoff, Lars. 2014. <span>“<span class="nocase">Algorithm selection for combinatorial search problems: A survey</span>.”</span> <em>AI Magazine</em> 35 (3): 48–69.
</div>
<div id="ref-erdem_ku__2024" class="csl-entry" role="listitem">
Kuş, Erdem, Özgür Akgün, Nguyen Dang, and Ian Miguel. 2024. <span>“<span>Frugal Algorithm Selection</span>.”</span> Cornell University. <a href="https://doi.org/ 10.48550/arxiv.2405.11059 ">https://doi.org/ 10.48550/arxiv.2405.11059 </a>.
</div>
<div id="ref-lefrioux" class="csl-entry" role="listitem">
Le Frioux, Ludovic. 2019. <span>“<span class="nocase">Towards more efficient parallel SAT solving</span>.”</span> Theses, <span>Sorbonne Universit<span>é</span></span>. <a href="https://theses.hal.science/tel-03030122">https://theses.hal.science/tel-03030122</a>.
</div>
<div id="ref-10.1145/3637225" class="csl-entry" role="listitem">
Leeson, Will, and Matthew B. Dwyer. 2024. <span>“<span class="nocase">Algorithm Selection for Software Verification Using Graph Neural Networks</span>.”</span> <em>ACM Trans. Softw. Eng. Methodol.</em> 33 (3). <a href="https://doi.org/10.1145/3637225">https://doi.org/10.1145/3637225</a>.
</div>
<div id="ref-10.5555/1630659.1630927" class="csl-entry" role="listitem">
Leyton-Brown, Kevin, Eugene Nudelman, Galen Andrew, Jim McFadden, and Yoav Shoham. 2003. <span>“<span class="nocase">A portfolio approach to algorithm selection</span>.”</span> In <em>Proceedings of the 18th International Joint Conference on Artificial Intelligence</em>, 1542–43. IJCAI’03. San Francisco, CA, USA: Morgan Kaufmann Publishers Inc.
</div>
<div id="ref-10.1007/3-540-46135-3_37" class="csl-entry" role="listitem">
Leyton-Brown, Kevin, Eugene Nudelman, and Yoav Shoham. 2002. <span>“<span class="nocase">Learning the Empirical Hardness of Optimization Problems: The Case of Combinatorial Auctions</span>.”</span> In <em>Principles and Practice of Constraint Programming - CP 2002</em>, edited by Pascal Van Hentenryck, 556–72. Berlin, Heidelberg: Springer Berlin Heidelberg.
</div>
<div id="ref-NIPS2014_7fb8ceb3" class="csl-entry" role="listitem">
Lieder, Falk, Dillon Plunkett, Jessica B Hamrick, Stuart J Russell, Nicholas Hay, and Tom Griffiths. 2014. <span>“Algorithm Selection by Rational Metareasoning as a Model of Human Strategy Selection.”</span> In <em>Advances in Neural Information Processing Systems</em>, edited by Z. Ghahramani, M. Welling, C. Cortes, N. Lawrence, and K. Q. Weinberger. Vol. 27. Curran Associates, Inc. <a href="https://proceedings.neurips.cc/paper_files/paper/2014/file/7fb8ceb3bd59c7956b1df66729296a4c-Paper.pdf">https://proceedings.neurips.cc/paper_files/paper/2014/file/7fb8ceb3bd59c7956b1df66729296a4c-Paper.pdf</a>.
</div>
<div id="ref-flexfolio" class="csl-entry" role="listitem">
Lindauer, Marius, Rolf-David Bergdoll, and Frank Hutter. 2016. <span>“An Empirical Study of Per-Instance Algorithm Scheduling.”</span> In <em>Proceedings of the Tenth International Conference on Learning and Intelligent Optimization, LION’16, in: Lecture Notes in Computer Science</em>, 253–59. Springer; Springer.
</div>
<div id="ref-lindauer2015autofolio" class="csl-entry" role="listitem">
Lindauer, Marius, Holger H Hoos, Frank Hutter, and Torsten Schaub. 2015. <span>“Autofolio: An Automatically Configured Algorithm Selector.”</span> <em>Journal of Artificial Intelligence Research</em> 53: 745–78.
</div>
<div id="ref-Marius2015" class="csl-entry" role="listitem">
Lindauer, Marius, Holger Hoos, and Frank Hutter. 2015. <span>“<span class="nocase">From sequential algorithm selection to parallel portfolio selection</span>.”</span> In <em>International Conference on Learning and Intelligent Optimization</em>, 1–16. Springer.
</div>
<div id="ref-LINDAUER201986" class="csl-entry" role="listitem">
Lindauer, Marius, Jan N. van Rijn, and Lars Kotthoff. 2019. <span>“<span class="nocase">The algorithm selection competitions 2015 and 2017</span>.”</span> <em>Artificial Intelligence</em> 272: 86–100. https://doi.org/<a href="https://doi.org/10.1016/j.artint.2018.10.004">https://doi.org/10.1016/j.artint.2018.10.004</a>.
</div>
<div id="ref-lindauer2014algorithm" class="csl-entry" role="listitem">
Lindauer, T Marius. 2014. <span>“<span class="nocase">Algorithm selection, scheduling and configuration of Boolean constraint solvers</span>.”</span> PhD thesis, Universit<span>ä</span>t Potsdam.
</div>
<div id="ref-10194439" class="csl-entry" role="listitem">
Lukac, Martin, and Michitaka Kameyama. 2023. <span>“<span>Verification Based Algorithm Selection</span>.”</span> In <em>2023 International Conference on Information and Digital Technologies (IDT)</em>, 25–30. <a href="https://doi.org/10.1109/IDT59031.2023.10194439">https://doi.org/10.1109/IDT59031.2023.10194439</a>.
</div>
<div id="ref-yuri_malitsky__2014" class="csl-entry" role="listitem">
Malitsky, Yuri, Barry O’Sullivan, Alessandro Previti, and Joao Marques-Silva. 2014. <span>“<span class="nocase">A Portfolio Approach to Enumerating Minimal Correction Subsets for Satisfiability Problems</span>.”</span> In, 368–76. Springer, Cham. <a href="https://doi.org/ 10.1007/978-3-319-07046-9_26 ">https://doi.org/ 10.1007/978-3-319-07046-9_26 </a>.
</div>
<div id="ref-p3s" class="csl-entry" role="listitem">
Malitsky, Yuri, Ashish Sabharwal, Horst Samulowitz, and Meinolf Sellmann. 2012. <span>“<span class="nocase">Parallel SAT Solver Selection and Scheduling</span>.”</span> In <em>Proceedings of the 18th International Conference on Principles and Practice of Constraint Programming - Volume 7514</em>, 512–26. Springer-Verlag.
</div>
<div id="ref-10.5555/2540128.2540217" class="csl-entry" role="listitem">
———. 2013. <span>“<span class="nocase">Algorithm portfolios based on cost-sensitive hierarchical clustering</span>.”</span> In <em>Proceedings of the Twenty-Third International Joint Conference on Artificial Intelligence</em>, 608–14. IJCAI ’13. Beijing, China: AAAI Press.
</div>
<div id="ref-manthey2011parallel" class="csl-entry" role="listitem">
Manthey, Norbert. 2011. <span>“<span class="nocase">Parallel SAT solving-using more cores</span>.”</span> <em>Pragmatics of SAT (POS’11)</em>.
</div>
<div id="ref-5547116" class="csl-entry" role="listitem">
Meyer, Quirin, Fabian Schönfeld, Marc Stamminger, and Rolf Wanka. 2010. <span>“<span class="nocase">3-SAT on CUDA: Towards a massively parallel SAT solver</span>.”</span> In <em>2010 International Conference on High Performance Computing &amp; Simulation</em>, 306–13. <a href="https://doi.org/10.1109/HPCS.2010.5547116">https://doi.org/10.1109/HPCS.2010.5547116</a>.
</div>
<div id="ref-GCP" class="csl-entry" role="listitem">
Musliu, Nysret, and Martin Schwengerer. 2013. <span>“<span class="nocase">Algorithm Selection for the Graph Coloring Problem</span>.”</span> In <em>Learning and Intelligent Optimization</em>, edited by Giuseppe Nicosia and Panos Pardalos, 389–403. Berlin, Heidelberg: Springer Berlin Heidelberg.
</div>
<div id="ref-osti_2223030" class="csl-entry" role="listitem">
Nichols, Daniel, Harshitha Menon, Todd Gamblin, and Abhinav Bhatele. 2023. <span>“<span class="nocase">A Probabilistic Approach To Selecting Build Configurations in Package Managers</span>,”</span> November. <a href="https://doi.org/10.2172/2223030">https://doi.org/10.2172/2223030</a>.
</div>
<div id="ref-10.1007/978-3-540-30201-8_33" class="csl-entry" role="listitem">
Nudelman, Eugene, Kevin Leyton-Brown, Holger H. Hoos, Alex Devkar, and Yoav Shoham. n.d. <span>“Understanding Random <span>SAT</span>: Beyond the Clauses-to-Variables Ratio.”</span> In <em>Principles and Practice of Constraint Programming – CP 2004</em>, edited by Mark Wallace, 438–52. Berlin, Heidelberg: Springer Berlin Heidelberg.
</div>
<div id="ref-cphydra" class="csl-entry" role="listitem">
O’Mahony, Eoin, Emmanuel Hebrard, Alan Holland, Conor Nugent, and Barry O’Sullivan. 2008. <span>“Using Case-Based Reasoning in an Algorithm Portfolio for Constraint Solving.”</span> In <em>Irish Conference on Artificial Intelligence and Cognitive Science</em>, 210–16. Proceedings of the 19th Irish Conference on Artificial Intelligence; Cognitive Science.
</div>
<div id="ref-10.1007/978-3-030-72016-2_8" class="csl-entry" role="listitem">
Osama, Muhammad, Anton Wijs, and Armin Biere. 2021. <span>“<span class="nocase">SAT Solving with GPU Accelerated Inprocessing</span>.”</span> In <em>Tools and Algorithms for the Construction and Analysis of Systems</em>, edited by Jan Friso Groote and Kim Guldstrand Larsen, 133–51. Cham: Springer International Publishing.
</div>
<div id="ref-10.1007/s10703-023-00432-z" class="csl-entry" role="listitem">
———. 2023. <span>“<span class="nocase">Certified SAT solving with GPU accelerated inprocessing</span>.”</span> <em>Form. Methods Syst. Des.</em> 62 (1–3): 79–118. <a href="https://doi.org/10.1007/s10703-023-00432-z">https://doi.org/10.1007/s10703-023-00432-z</a>.
</div>
<div id="ref-10.5555/525" class="csl-entry" role="listitem">
Pearl, Judea. 1984. <em>Heuristics: Intelligent Search Strategies for Computer Problem Solving</em>. USA: Addison-Wesley Longman Publishing Co., Inc.
</div>
<div id="ref-10.1007/978-3-030-80223-3_31" class="csl-entry" role="listitem">
Pimpalkhare, Nikhil, Federico Mora, Elizabeth Polgreen, and Sanjit A. Seshia. 2021. <span>“<span>MedleySolver: Online SMT Algorithm Selection</span>.”</span> In <em>Theory and Applications of Satisfiability Testing – SAT 2021</em>, edited by Chu-Min Li and Felip Manyà, 453–70. Cham: Springer International Publishing.
</div>
<div id="ref-pmlr-v188-pulatov22a" class="csl-entry" role="listitem">
Pulatov, Damir, Marie Anastacio, Lars Kotthoff, and Holger Hoos. 2022. <span>“<span class="nocase">Opening the Black Box: Automated Software Analysis for Algorithm Selection</span>.”</span> In <em>Proceedings of the First International Conference on Automated Machine Learning</em>, 188:6/1–18. PMLR. <a href="https://proceedings.mlr.press/v188/pulatov22a.html">https://proceedings.mlr.press/v188/pulatov22a.html</a>.
</div>
<div id="ref-PULINA2019224" class="csl-entry" role="listitem">
Pulina, Luca, and Martina Seidl. 2019. <span>“The 2016 and 2017 <span>QBF</span> Solvers Evaluations (<span>QBFEVAL’16</span> and <span>QBFEVAL’17</span>).”</span> <em>Artificial Intelligence</em> 274: 224–48. https://doi.org/<a href="https://doi.org/10.1016/j.artint.2019.04.002">https://doi.org/10.1016/j.artint.2019.04.002</a>.
</div>
<div id="ref-10.1007/3-540-44614-1_50" class="csl-entry" role="listitem">
Redekopp, M., and A. Dandalis. 2000. <span>“<span class="nocase">A Parallel Pipelined SAT Solver for FPGA’s</span>.”</span> In <em>Field-Programmable Logic and Applications: The Roadmap to Reconfigurable Computing</em>, edited by Reiner W. Hartenstein and Herbert Grünbacher, 462–68. Berlin, Heidelberg: Springer Berlin Heidelberg.
</div>
<div id="ref-Rice1976" class="csl-entry" role="listitem">
Rice, John R. 1976. <span>“<span>The Algorithm Selection Problem</span>.”</span> <em>Advances in Computers</em>. <a href="https://doi.org/10.1016/S0065-2458(08)60520-3">https://doi.org/10.1016/S0065-2458(08)60520-3</a>.
</div>
<div id="ref-10.1007/s10515-020-00270-x" class="csl-entry" role="listitem">
Richter, Cedric, Eyke Hüllermeier, Marie-Christine Jakobs, and Heike Wehrheim. 2020. <span>“Algorithm Selection for Software Validation Based on Graph Kernels.”</span> <em>Automated Software Engg.</em> 27 (1–2): 153–86. <a href="https://doi.org/10.1007/s10515-020-00270-x">https://doi.org/10.1007/s10515-020-00270-x</a>.
</div>
<div id="ref-roberts2008makes" class="csl-entry" role="listitem">
Roberts, Mark, Adele E Howe, Brandon Wilson, and Marie desJardins. 2008. <span>“<span>What Makes Planners Predictable?</span>”</span> In <em>ICAPS</em>, 288–95.
</div>
<div id="ref-ppfolio" class="csl-entry" role="listitem">
Roussel, Olivier. 2012. <span>“Description of Ppfolio (2011).”</span> <em>Proc. SAT Challenge</em>, 46.
</div>
<div id="ref-shavit_et_al" class="csl-entry" role="listitem">
Shavit, Hadar, and Holger H. Hoos. 2024. <span>“<span class="nocase">Revisiting SATZilla Features in 2024</span>.”</span> In <em>27th International Conference on Theory and Applications of Satisfiability Testing (SAT 2024)</em>, edited by Supratik Chakraborty and Jie-Hong Roland Jiang, 305:27:1–26. Leibniz International Proceedings in Informatics (LIPIcs). Dagstuhl, Germany: Schloss Dagstuhl – Leibniz-Zentrum f<span>ü</span>r Informatik. <a href="https://doi.org/10.4230/LIPIcs.SAT.2024.27">https://doi.org/10.4230/LIPIcs.SAT.2024.27</a>.
</div>
<div id="ref-10.1007/11752578_46" class="csl-entry" role="listitem">
Singer, Daniel, and Alain Vagner. 2006. <span>“<span class="nocase">Parallel Resolution of the Satisfiability Problem (SAT) with OpenMP and MPI</span>.”</span> In <em>Parallel Processing and Applied Mathematics</em>, edited by Roman Wyrzykowski, Jack Dongarra, Norbert Meyer, and Jerzy Waśniewski, 380–88. Berlin, Heidelberg: Springer Berlin Heidelberg.
</div>
<div id="ref-SINZ2001205" class="csl-entry" role="listitem">
Sinz, Carsten, Wolfgang Blochinger, and Wolfgang Küchlin. 2001. <span>“<span class="nocase">PaSAT — Parallel SAT-Checking with Lemma Exchange: Implementation and Applications</span>.”</span> <em>Electronic Notes in Discrete Mathematics</em> 9: 205–16. https://doi.org/<a href="https://doi.org/10.1016/S1571-0653(04)00323-3">https://doi.org/10.1016/S1571-0653(04)00323-3</a>.
</div>
<div id="ref-10.1109/CEC55065.2022.9870417" class="csl-entry" role="listitem">
Sitaru, Ioana, and Madalina Raschip. 2022. <span>“<span class="nocase">Algorithm Selection for Combinatorial Packing Problems</span>.”</span> In <em>2022 IEEE Congress on Evolutionary Computation (CEC)</em>, 1–8. Padua, Italy: IEEE Press. <a href="https://doi.org/10.1109/CEC55065.2022.9870417">https://doi.org/10.1109/CEC55065.2022.9870417</a>.
</div>
<div id="ref-SMITHMILES2012875" class="csl-entry" role="listitem">
Smith-Miles, Kate, and Leo Lopes. 2012. <span>“Measuring Instance Difficulty for Combinatorial Optimization Problems.”</span> <em>Computers &amp; Operations Research</em> 39 (5): 875–89. https://doi.org/<a href="https://doi.org/10.1016/j.cor.2011.07.006">https://doi.org/10.1016/j.cor.2011.07.006</a>.
</div>
<div id="ref-10.5120/ijca2016910726" class="csl-entry" role="listitem">
Somshubra Majumdar, Kunal Kukreja, Ishaan Jain. 2016. <span>“<span class="nocase">AdaSort: Adaptive Sorting using Machine Learning</span>.”</span> <em>International Journal of Computer Applications</em> 145 (12): 12–17. <a href="https://doi.org/ 10.5120/ijca2016910726 ">https://doi.org/ 10.5120/ijca2016910726 </a>.
</div>
<div id="ref-Stuckey_Feydy_Schutt_Tack_Fischer_2014" class="csl-entry" role="listitem">
Stuckey, Peter J., Thibaut Feydy, Andreas Schutt, Guido Tack, and Julien Fischer. 2014. <span>“<span>The MiniZinc Challenge 2008–2013</span>.”</span> <em>AI Magazine</em> 35 (2): 55–60. <a href="https://doi.org/10.1609/aimag.v35i2.2539">https://doi.org/10.1609/aimag.v35i2.2539</a>.
</div>
<div id="ref-taitler-et-al-aimag2024" class="csl-entry" role="listitem">
Taitler, Ayal, Ron Alford, Joan Espasa, Gregor Behnke, Daniel Fišer, Michael Gimelfarb, Florian Pommerening, et al. 2024. <span>“The 2023 <span>International Planning Competition</span>.”</span> <em>AI Magazine</em>, 1–17.
</div>
<div id="ref-10.1145/2487575.2487629" class="csl-entry" role="listitem">
Thornton, Chris, Frank Hutter, Holger H. Hoos, and Kevin Leyton-Brown. 2013. <span>“<span class="nocase">Auto-WEKA: combined selection and hyperparameter optimization of classification algorithms</span>.”</span> In <em>Proceedings of the 19th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</em>, 847–55. KDD ’13. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/2487575.2487629">https://doi.org/10.1145/2487575.2487629</a>.
</div>
<div id="ref-10.5555/3007337.3007474" class="csl-entry" role="listitem">
Valenzano, Richard, Hootan Nakhost, Martin Müller, Jonathan Schaeffer, and Nathan Sturtevant. 2012. <span>“ArvandHerd: Parallel Planning with a Portfolio.”</span> In <em>Proceedings of the 20th European Conference on Artificial Intelligence</em>, 786–91. ECAI’12. NLD: IOS Press.
</div>
<div id="ref-Vanschoren2019" class="csl-entry" role="listitem">
Vanschoren, Joaquin. 2019. <span>“Meta-Learning.”</span> In <em>Automated Machine Learning: Methods, Systems, Challenges</em>, edited by Frank Hutter, Lars Kotthoff, and Joaquin Vanschoren, 35–61. Cham: Springer International Publishing. <a href="https://doi.org/10.1007/978-3-030-05318-5_2">https://doi.org/10.1007/978-3-030-05318-5_2</a>.
</div>
<div id="ref-explainability" class="csl-entry" role="listitem">
Visentin, Andrea, Aodh Ó Gallchóir, Jens Kärcher, and Herbert Meyr. 2024. <span>“<span class="nocase">Explainable Algorithm Selection for the Capacitated Lot Sizing Problem</span>.”</span> In <em>Integration of Constraint Programming, Artificial Intelligence, and Operations Research</em>, edited by Bistra Dilkina, 243–52. Cham: Springer Nature Switzerland.
</div>
<div id="ref-9463528" class="csl-entry" role="listitem">
Wang, Qiang, Jiawei Jiang, Yongxin Zhao, Weipeng Cao, Chunjiang Wang, and Shengdong Li. 2021. <span>“<span class="nocase">Algorithm selection for software verification based on adversarial LSTM</span>.”</span> In <em>2021 7th IEEE Intl Conference on Big Data Security on Cloud (BigDataSecurity), IEEE Intl Conference on High Performance and Smart Computing, (HPSC) and IEEE Intl Conference on Intelligent Data and Security (IDS)</em>, 87–92. <a href="https://doi.org/10.1109/BigDataSecurityHPSCIDS52275.2021.00026">https://doi.org/10.1109/BigDataSecurityHPSCIDS52275.2021.00026</a>.
</div>
<div id="ref-books/daglib/0030297" class="csl-entry" role="listitem">
Williamson, David P., and David B. Shmoys. 2011. <em>The Design of Approximation Algorithms.</em> Cambridge University Press.
</div>
<div id="ref-gerhard_j__woeginger_2002" class="csl-entry" role="listitem">
Woeginger, Gerhard J. 2002. <span>“Exact Algorithms for <span class="nocase">NP-hard</span> Problems: A Survey.”</span> In, 185–207. Springer, Berlin, Heidelberg. <a href="https://doi.org/ 10.1007/3-540-36478-1_17 ">https://doi.org/ 10.1007/3-540-36478-1_17 </a>.
</div>
<div id="ref-585893" class="csl-entry" role="listitem">
Wolpert, D. H., and W. G. Macready. 1997. <span>“No Free Lunch Theorems for Optimization.”</span> <em>IEEE Transactions on Evolutionary Computation</em> 1 (1): 67–82. <a href="https://doi.org/10.1109/4235.585893">https://doi.org/10.1109/4235.585893</a>.
</div>
<div id="ref-wotzlawpfoliouzk" class="csl-entry" role="listitem">
Wotzlaw, Andreas, Alexander van der Grinten, Ewald Speckenmeyer, and Stefan Porschen. 2012. <span>“<span class="nocase">pfolioUZK: Solver description</span>.”</span> <em>Balint Et Al.(Balint Et Al., 2012a)</em>, 45.
</div>
<div id="ref-10.5555/2898607.2898641" class="csl-entry" role="listitem">
Xu, Lin, Holger H. Hoos, and Kevin Leyton-Brown. 2010. <span>“<span class="nocase">Hydra: Automatically Configuring Algorithms for Portfolio-Based Selection</span>.”</span> In <em>Proceedings of the Twenty-Fourth AAAI Conference on Artificial Intelligence</em>, 210–16. AAAI’10 1. AAAI Press.
</div>
<div id="ref-satzilla" class="csl-entry" role="listitem">
Xu, Lin, Frank Hutter, Holger H. Hoos, and Kevin Leyton-Brown. 2008. <span>“<span>SATzilla</span>: Portfolio-Based Algorithm Selection for <span>SAT</span>.”</span> <em>J. Artif. Int. Res.</em> 32 (1): 565–606.
</div>
<div id="ref-XuEtAl11" class="csl-entry" role="listitem">
Xu, Lin, Frank Hutter, Holger H Hoos, and Kevin Leyton-Brown. 2011. <span>“<span class="nocase">Hydra-MIP: Automated algorithm configuration and selection for mixed integer programming</span>.”</span> In <em>Proceedings of the 18th RCRA Workshop</em>, 16–30.
</div>
<div id="ref-10.1007/978-3-642-31612-8_18" class="csl-entry" role="listitem">
Xu, Lin, Frank Hutter, Holger Hoos, and Kevin Leyton-Brown. 2012. <span>“<span class="nocase">Evaluating Component Solver Contributions to Portfolio-Based Algorithm Selectors</span>.”</span> In <em>Theory and Applications of Satisfiability Testing – SAT 2012</em>, edited by Alessandro Cimatti and Roberto Sebastiani, 228–41. Berlin, Heidelberg: Springer Berlin Heidelberg.
</div>
<div id="ref-ZHANG1996543" class="csl-entry" role="listitem">
ZHANG, HANTAO, MARIA PAOLA BONACINA, and JIEH HSIANG. 1996. <span>“<span class="nocase">PSATO: a Distributed Propositional Prover and its Application to Quasigroup Problems</span>.”</span> <em>Journal of Symbolic Computation</em> 21 (4): 543–60. https://doi.org/<a href="https://doi.org/10.1006/jsco.1996.0030">https://doi.org/10.1006/jsco.1996.0030</a>.
</div>
<div id="ref-707896" class="csl-entry" role="listitem">
Zhong, Peixin, M. Martonosi, P. Ashar, and S. Malik. 1998. <span>“<span class="nocase">Accelerating Boolean satisfiability with configurable hardware</span>.”</span> In <em><span class="nocase">Proceedings. IEEE Symposium on FPGAs for Custom Computing Machines (Cat. No.98TB100251)</span></em>, 186–95. <a href="https://doi.org/10.1109/FPGA.1998.707896">https://doi.org/10.1109/FPGA.1998.707896</a>.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../chapters/chapter1/Introduction.html" class="pagination-link" aria-label="Introduction">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introduction</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../chapters/chapter3/IsAlgorithmSelectionWorthItComparingSelectingSingleAlgorithmsandParallelExecution.html" class="pagination-link" aria-label="Is Algorithm Selection Worth It? Comparing Selecting Single Algorithms and Parallel Execution">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Is Algorithm Selection Worth It? Comparing Selecting Single Algorithms and Parallel Execution</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb1" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> Background</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Combinatorial problems involve problems whose goal is to find the best</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>arrangement or selection from a finite set of items. These problems</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>mainly focus on assignment, sorting, selection, and optimization tasks</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>such as scheduling and routing. These challenges are common in multiple</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>disciplines, such as computer science, operations research,</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>bioinformatics, and artificial intelligence <span class="co">[</span><span class="ot">@series/faia/336</span><span class="co">]</span>. Many</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>combinatorial problems fall into the categories of NP-complete or</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>NP-hard, meaning they can be significantly computationally expensive.</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>Common examples of these problems include boolean satisfiability (SAT),</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>integer programming (IP), quantified boolean formulas (QBF), constraint</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>satisfaction problem (CSP), and any other NP-complete problems like the</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>21 Karp NP-complete problems <span class="co">[</span><span class="ot">@Karp1972</span><span class="co">]</span>. Additionally, NP-hard problems</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>such as the traveling salesman (TSP), answer set programming (ASP),</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>scheduling, and mixed-integer programming (MIP) fall into this category.</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>Over several decades, various algorithms and complex mathematical</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>methods have been developed to solve these problems, which mainly deal</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>with discrete optimization.</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>Every year, competitions are held to compare the proposed algorithms.</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>For example, the SAT community organized annual SAT competitions to</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>evaluate and benchmark algorithms on various tracks and domains</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@balyo_sat_2017</span><span class="co">]</span>. Similarly, annual QBF solver evaluations (QBFEVAL),</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>MiniZinc Challenge, ASP Competition, and International Planning</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>Competition exist, focusing on quantified Boolean formulas, constraint</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>programming, ASP and planning solvers, respectively</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@PULINA2019224; @Stuckey_Feydy_Schutt_Tack_Fischer_2014; @GEBSER_2019; @taitler-et-al-aimag2024</span><span class="co">]</span>.</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>Many solvers have been proposed and continue to evolve, leading to</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>significant improvements in both efficiency and effectiveness. In</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>addition to exact solvers <span class="co">[</span><span class="ot">@gerhard_j__woeginger_2002</span><span class="co">]</span>, researchers have</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>also explored approximation algorithms <span class="co">[</span><span class="ot">@books/daglib/0030297</span><span class="co">]</span> and</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>heuristics <span class="co">[</span><span class="ot">@10.5555/525</span><span class="co">]</span> as alternatives to achieve solutions close to</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>the optimum, particularly in cases where exact solutions are</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>computationally infeasible. These methods often leverage</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>problem-specific knowledge to guide the search process, and they often</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>sacrifice optimality for speed and produce suboptimal solutions.</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>Moreover, the inherent difficulty of these problems means that no</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>polynomial-time solutions are known, and there is no one-size-fits-all</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>solution to solve them. The \"No Free Lunch\" theorem formalizes the</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>idea that, when considering every possible problem, no algorithm</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>outperforms others on average; they all have equivalent performance</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@585893</span><span class="co">]</span>. It is the problem-specific performance that makes some</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>algorithms appear to be better suited for certain domains <span class="co">[</span><span class="ot">@585893</span><span class="co">]</span>. The</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>performance of any algorithm is limited by the specific characteristics</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>of the problem instance it encounters. The results of</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@10.1007/978-3-540-30201-8_33</span><span class="co">]</span> contribute to a deeper understanding of</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>the relationship between the characteristics of the instance (that is,</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>the number of clauses and variables in the SAT), which is known to</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>correlate with the difficulty of the problem.</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>In the realm of algorithm development, both sequential and parallel</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>solvers have been extensively studied. Theoretically, many</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>problem-solving approaches were originally sequential. For instance, in</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>the SAT domain, Davis-Putnam-Loveland-Logemann (DPLL) algorithm</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@10.1145/368273.368557</span><span class="co">]</span> was initially designed to be sequential.</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>Sequential solvers generally operate without awareness of available</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>resources and do not dynamically adapt to them. The results of</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@10.1007/978-3-642-16242-8_37</span><span class="co">]</span> have revealed that the performance and</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>efficiency of a sequential solver depend heavily on hardware resources</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>and low-level processing. This underscores the need to utilize parallel</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>resources in problem-solving to improve the performance.</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a><span class="fu">## Parallel Solvers</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>Parallel solvers then emerged as multicore architectures became</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>increasingly accessible. Initially, the first parallel SAT solvers</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>utilized single-core CPUs, with multiple units communicating over a</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>network and employing the leader-follower model</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@holldobler_short_2011</span><span class="co">]</span>. This approach is showcased by PMSat, a</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>parallel version of the sequential MiniSAT solver</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@journals/jsat/GilFS09</span><span class="co">]</span>, as well as the PSATO solvers <span class="co">[</span><span class="ot">@ZHANG1996543</span><span class="co">]</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>and PaSAT <span class="co">[</span><span class="ot">@SINZ2001205</span><span class="co">]</span>, which introduced search-space partitioning</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>between processing units communicating over MPI in distributed systems</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@10.1007/978-3-642-16242-8_27</span><span class="co">]</span>. Additionally, advancements in algorithm</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>design made the development of parallel solvers possible. For example,</span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>in the SAT domain, the transition from DPLL solvers to Conflict-Driven</span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>Clause Learning (CDCL) solvers <span class="co">[</span><span class="ot">@biere2009conflict</span><span class="co">]</span>, divide-and-conquer</span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>techniques <span class="co">[</span><span class="ot">@lefrioux</span><span class="co">]</span>, and the implementation of restart strategies</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@10.1007/978-3-540-85110-3_11</span><span class="co">]</span> facilitated the parallelization of</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>existing algorithm designs. These design let the solvers share the</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>learned clauses or split search spaces between processing units.</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>Following the emergence of shared memory architectures, parallel solvers</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>started to exploit multicore CPUs with shared memory among cores</span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@10.1007/11752578_46</span><span class="co">]</span>. Modern parallel solvers inherited the methods</span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>developed from earlier distributed parallelization approaches. For</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>example, the parallel SAT solver, Plingeling <span class="co">[</span><span class="ot">@plingeling</span><span class="co">]</span>, inherits its</span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>algorithm design from the sequential Lingeling solver and incorporates a</span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>clause-sharing technique among cores for SAT solving. However, in</span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>earlier versions of Plingeling, despite using shared-memory systems,</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>clauses were copied by each core. As noted in</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@Biere2013LingelingPA; @conf/sat/AignerBKNP13</span><span class="co">]</span>, the memory used by each</span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>processing unit was physically separated, leading to an n-fold increase</span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>in memory usage.</span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>Other solvers, such as the one proposed in</span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@hyvarinen2012approaches; @manthey2011parallel</span><span class="co">]</span>, used a more finer</span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>granularity in their parallelization approach where multiple cores</span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>exchange clauses to solve the problem; however, these methods were not</span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>scalable to a high number of cores and resulted in limited improvement.</span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>With regard to modern graphical processing unit (GPU) and</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a>field-programmable gate array (FPGA) computing, several solutions have</span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>been proposed</span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@10.1007/3-540-44614-1_50; @707896; @4555925; @10.1145/1497561.1497576; @10.1007/s10703-023-00432-z; @11390_1234673; @5547116; @10.1007/978-3-030-72016-2_8</span><span class="co">]</span>.</span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a>However, some have not demonstrated promising results and while some</span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>show potential, discussions of these solvers are outside the focus of</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>this thesis.</span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>Despite all the developments in parallel computing and parallel</span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>algorithm designs, the transition from sequential to parallel solvers</span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a>remains highly challenging, if not impossible, in some cases. Most</span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>solvers are originally designed for sequential execution; therefore,</span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>adapting them to parallel environments often requires a thorough</span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>understanding of the problem domain, algorithm design, and many core</span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>systems.</span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>A number of works have shown that this problem can be overcome by</span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a>improving performance without directly developing new solvers. Instead,</span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a>existing solvers can be used and combined in a portfolio, selecting the</span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a>appropriate solver(s) <span class="co">[</span><span class="ot">@Kotthoff2014; @satzilla; @kadiogluwin</span><span class="co">]</span>. In cases</span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a>where multiple solvers are chosen, they can be run in a schedule, in</span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a>parallel, or in combination with each other to achieve superior</span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a>performance.</span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a>&lt;figure id="fig:nativealgselec"&gt;</span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a>&lt;div class="lrbox"&gt;</span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a>&lt;img src="plots/as.png" style="width:90%"/&gt;</span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a>&lt;/div&gt;</span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a>&lt;figcaption&gt;Algorithm Selection using ML models&lt;/figcaption&gt;</span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a>&lt;/figure&gt;</span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a><span class="fu">## Algorithm Selection</span></span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a>Algorithm selection is a meta-algorithmic technique that was first</span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true" tabindex="-1"></a>introduced by John Rice <span class="co">[</span><span class="ot">@Rice1976</span><span class="co">]</span> in 1976. The algorithm selection</span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true" tabindex="-1"></a>problem is strategically choosing the most suitable algorithm from a set</span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true" tabindex="-1"></a>of candidates to solve a specific problem instance using the features</span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true" tabindex="-1"></a>and characteristics of the problem instances. This problem is closely</span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true" tabindex="-1"></a>related to general optimization theory, as both involve finding the best</span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true" tabindex="-1"></a>solution among a set of options <span class="co">[</span><span class="ot">@Rice1976</span><span class="co">]</span>. Algorithm selection is an</span>
<span id="cb1-147"><a href="#cb1-147" aria-hidden="true" tabindex="-1"></a>important task in optimizing the performance of computationally</span>
<span id="cb1-148"><a href="#cb1-148" aria-hidden="true" tabindex="-1"></a>expensive tasks, particularly those that can be translated into</span>
<span id="cb1-149"><a href="#cb1-149" aria-hidden="true" tabindex="-1"></a>combinatorial problems <span class="co">[</span><span class="ot">@Kotthoff2014</span><span class="co">]</span>, NP-complete and NP-hard problems</span>
<span id="cb1-150"><a href="#cb1-150" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@GCP; @10.1109/CEC55065.2022.9870417</span><span class="co">]</span>.</span>
<span id="cb1-151"><a href="#cb1-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-152"><a href="#cb1-152" aria-hidden="true" tabindex="-1"></a>During the last two decades, the algorithm selection problem has</span>
<span id="cb1-153"><a href="#cb1-153" aria-hidden="true" tabindex="-1"></a>attracted significant attention from both researchers and practitioners</span>
<span id="cb1-154"><a href="#cb1-154" aria-hidden="true" tabindex="-1"></a>as it is relevant in various domains, including high-performance</span>
<span id="cb1-155"><a href="#cb1-155" aria-hidden="true" tabindex="-1"></a>computing <span class="co">[</span><span class="ot">@FlorinaOpneMP</span><span class="co">]</span>, sorting <span class="co">[</span><span class="ot">@10.5120/ijca2016910726</span><span class="co">]</span>,</span>
<span id="cb1-156"><a href="#cb1-156" aria-hidden="true" tabindex="-1"></a>probabilistic inference <span class="co">[</span><span class="ot">@sotingAS; @KOCAMAZ201394</span><span class="co">]</span>, software validation</span>
<span id="cb1-157"><a href="#cb1-157" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@10.1007/s10515-020-00270-x</span><span class="co">]</span>, software verification</span>
<span id="cb1-158"><a href="#cb1-158" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@9463528; @10.1145/3637225</span><span class="co">]</span>, software package dependency management</span>
<span id="cb1-159"><a href="#cb1-159" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@osti_2223030</span><span class="co">]</span> and data mining</span>
<span id="cb1-160"><a href="#cb1-160" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@10.4108/ICST.SIMUTOOLS2009.5659; @10.1145/3411564.3411646</span><span class="co">]</span>. Algorithm</span>
<span id="cb1-161"><a href="#cb1-161" aria-hidden="true" tabindex="-1"></a>selection is also applicable in the fields of meta-learning and</span>
<span id="cb1-162"><a href="#cb1-162" aria-hidden="true" tabindex="-1"></a>automated machine learning (AutoML), where the goal is to build a</span>
<span id="cb1-163"><a href="#cb1-163" aria-hidden="true" tabindex="-1"></a>meta-model that recommends the best machine learning algorithm,</span>
<span id="cb1-164"><a href="#cb1-164" aria-hidden="true" tabindex="-1"></a>configurations and hyper-parameters for a given training task</span>
<span id="cb1-165"><a href="#cb1-165" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@brazdil2022metalearning; @Vanschoren2019; @hutter2019automated</span><span class="co">]</span>. In</span>
<span id="cb1-166"><a href="#cb1-166" aria-hidden="true" tabindex="-1"></a>algorithm selection problem, the search space is a discrete set of</span>
<span id="cb1-167"><a href="#cb1-167" aria-hidden="true" tabindex="-1"></a>algorithms, while in problems such as the hyperparameter optimization</span>
<span id="cb1-168"><a href="#cb1-168" aria-hidden="true" tabindex="-1"></a>(HPO) and the combination algorithm selection and hyperparameter</span>
<span id="cb1-169"><a href="#cb1-169" aria-hidden="true" tabindex="-1"></a>optimization (CASH) problem <span class="co">[</span><span class="ot">@10.1145/2487575.2487629</span><span class="co">]</span>, the search</span>
<span id="cb1-170"><a href="#cb1-170" aria-hidden="true" tabindex="-1"></a>spaces are typically continuous or heterogeneous configuration spaces</span>
<span id="cb1-171"><a href="#cb1-171" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@brazdil2022metalearning</span><span class="co">]</span>.</span>
<span id="cb1-172"><a href="#cb1-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-173"><a href="#cb1-173" aria-hidden="true" tabindex="-1"></a>Algorithm selection is sometimes known as portfolio-based algorithm</span>
<span id="cb1-174"><a href="#cb1-174" aria-hidden="true" tabindex="-1"></a>selection in the literature <span class="co">[</span><span class="ot">@10.5555/2898607.2898641; @XuEtAl11</span><span class="co">]</span>, and</span>
<span id="cb1-175"><a href="#cb1-175" aria-hidden="true" tabindex="-1"></a>is used in combination with automatic algorithm configuration. Algorithm</span>
<span id="cb1-176"><a href="#cb1-176" aria-hidden="true" tabindex="-1"></a>Configuration is a specialized subset of algorithm selection</span>
<span id="cb1-177"><a href="#cb1-177" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@10.1007/978-3-319-09584-4_4</span><span class="co">]</span> in which algorithms with varying</span>
<span id="cb1-178"><a href="#cb1-178" aria-hidden="true" tabindex="-1"></a>configuration parameters build a portfolio. The configuration parameters</span>
<span id="cb1-179"><a href="#cb1-179" aria-hidden="true" tabindex="-1"></a>of these algorithms are dynamically adjusted based on the problem</span>
<span id="cb1-180"><a href="#cb1-180" aria-hidden="true" tabindex="-1"></a>instance. This allows algorithms to adapt to the specifics of a problem,</span>
<span id="cb1-181"><a href="#cb1-181" aria-hidden="true" tabindex="-1"></a>potentially improving their performance. This approach involves using</span>
<span id="cb1-182"><a href="#cb1-182" aria-hidden="true" tabindex="-1"></a>different configurations of an algorithm to design a portfolio of</span>
<span id="cb1-183"><a href="#cb1-183" aria-hidden="true" tabindex="-1"></a>solvers and choose the appropriate algorithm to solve problems. Focusing</span>
<span id="cb1-184"><a href="#cb1-184" aria-hidden="true" tabindex="-1"></a>on the literature on algorithm configuration techniques is beyond the</span>
<span id="cb1-185"><a href="#cb1-185" aria-hidden="true" tabindex="-1"></a>scope of this chapter.</span>
<span id="cb1-186"><a href="#cb1-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-187"><a href="#cb1-187" aria-hidden="true" tabindex="-1"></a>A traditional approach to address algorithm selection is the</span>
<span id="cb1-188"><a href="#cb1-188" aria-hidden="true" tabindex="-1"></a>\"winner-take-all\" or per-set algorithm selection strategy</span>
<span id="cb1-189"><a href="#cb1-189" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@10.1162/evco_a_00242</span><span class="co">]</span>, where different algorithms are evaluated based</span>
<span id="cb1-190"><a href="#cb1-190" aria-hidden="true" tabindex="-1"></a>on their performance across a problem distribution, and the one with the</span>
<span id="cb1-191"><a href="#cb1-191" aria-hidden="true" tabindex="-1"></a>lowest average runtime is chosen. However, this per-distribution</span>
<span id="cb1-192"><a href="#cb1-192" aria-hidden="true" tabindex="-1"></a>selection often leads to the neglect of algorithms that may not perform</span>
<span id="cb1-193"><a href="#cb1-193" aria-hidden="true" tabindex="-1"></a>well on average, but could excel in specific instances</span>
<span id="cb1-194"><a href="#cb1-194" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@10.5555/1630659.1630927</span><span class="co">]</span>. Per-instance algorithm selection, however,</span>
<span id="cb1-195"><a href="#cb1-195" aria-hidden="true" tabindex="-1"></a>has proven effective in numerous problem solving scenarios</span>
<span id="cb1-196"><a href="#cb1-196" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@BISCHL201641</span><span class="co">]</span>.</span>
<span id="cb1-197"><a href="#cb1-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-198"><a href="#cb1-198" aria-hidden="true" tabindex="-1"></a>Instance-based selection of an effective algorithm is inherently</span>
<span id="cb1-199"><a href="#cb1-199" aria-hidden="true" tabindex="-1"></a>complex, and evaluation of numerous algorithms against various</span>
<span id="cb1-200"><a href="#cb1-200" aria-hidden="true" tabindex="-1"></a>performance criteria is needed, which can lead to significant</span>
<span id="cb1-201"><a href="#cb1-201" aria-hidden="true" tabindex="-1"></a>computational demands. In addition, the abundance of algorithms designed</span>
<span id="cb1-202"><a href="#cb1-202" aria-hidden="true" tabindex="-1"></a>to address different types of problem has underscored the importance of</span>
<span id="cb1-203"><a href="#cb1-203" aria-hidden="true" tabindex="-1"></a>developing effective strategies for selecting the best algorithm for a</span>
<span id="cb1-204"><a href="#cb1-204" aria-hidden="true" tabindex="-1"></a>given context. The field of algorithm selection has evolved</span>
<span id="cb1-205"><a href="#cb1-205" aria-hidden="true" tabindex="-1"></a>significantly to address these challenges and there is a wide choice of</span>
<span id="cb1-206"><a href="#cb1-206" aria-hidden="true" tabindex="-1"></a>algorithm selection techniques available in the literature.</span>
<span id="cb1-207"><a href="#cb1-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-208"><a href="#cb1-208" aria-hidden="true" tabindex="-1"></a>One key component of per-instance algorithm selection is feature</span>
<span id="cb1-209"><a href="#cb1-209" aria-hidden="true" tabindex="-1"></a>selection. In order to improve the design and selection of algorithms,</span>
<span id="cb1-210"><a href="#cb1-210" aria-hidden="true" tabindex="-1"></a>measuring the difficulty of instances and identifying features of the</span>
<span id="cb1-211"><a href="#cb1-211" aria-hidden="true" tabindex="-1"></a>instance that contribute to its complexity is a fundamental task</span>
<span id="cb1-212"><a href="#cb1-212" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@SMITHMILES2012875; @10.1007/978-3-319-32034-2_25</span><span class="co">]</span>. Different studies</span>
<span id="cb1-213"><a href="#cb1-213" aria-hidden="true" tabindex="-1"></a>have concluded that problem instance features contribute distinctively</span>
<span id="cb1-214"><a href="#cb1-214" aria-hidden="true" tabindex="-1"></a>to the performance of different solvers. <span class="co">[</span><span class="ot">@10.1007/3-540-46135-3_37</span><span class="co">]</span></span>
<span id="cb1-215"><a href="#cb1-215" aria-hidden="true" tabindex="-1"></a>used statistical regression models to understand the empirical hardness</span>
<span id="cb1-216"><a href="#cb1-216" aria-hidden="true" tabindex="-1"></a>of NP-hard problems, which is believed to help tailor algorithms based</span>
<span id="cb1-217"><a href="#cb1-217" aria-hidden="true" tabindex="-1"></a>on the hardness of instances. <span class="co">[</span><span class="ot">@10.1007/978-3-540-30201-8_33</span><span class="co">]</span> also</span>
<span id="cb1-218"><a href="#cb1-218" aria-hidden="true" tabindex="-1"></a>contributed to understanding the impact of the features of SAT instances</span>
<span id="cb1-219"><a href="#cb1-219" aria-hidden="true" tabindex="-1"></a>on the difficulty of the problem. In short, the literature pertaining to</span>
<span id="cb1-220"><a href="#cb1-220" aria-hidden="true" tabindex="-1"></a>the study of instance features strongly suggests that solvers need to be</span>
<span id="cb1-221"><a href="#cb1-221" aria-hidden="true" tabindex="-1"></a>either designed to address a specific instance or carefully selected to</span>
<span id="cb1-222"><a href="#cb1-222" aria-hidden="true" tabindex="-1"></a>solve the particular problem.</span>
<span id="cb1-223"><a href="#cb1-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-224"><a href="#cb1-224" aria-hidden="true" tabindex="-1"></a>For various types of problem, numerous studies have focused on</span>
<span id="cb1-225"><a href="#cb1-225" aria-hidden="true" tabindex="-1"></a>collecting and identifying features to aid in training performant</span>
<span id="cb1-226"><a href="#cb1-226" aria-hidden="true" tabindex="-1"></a>algorithm selectors. In the domain of SAT, works such as</span>
<span id="cb1-227"><a href="#cb1-227" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@10.1007/978-3-540-30201-8_33; @satzilla; @HUTTER201479</span><span class="co">]</span> have made</span>
<span id="cb1-228"><a href="#cb1-228" aria-hidden="true" tabindex="-1"></a>significant contributions by extracting features from the CNF formulas</span>
<span id="cb1-229"><a href="#cb1-229" aria-hidden="true" tabindex="-1"></a>of SAT instances. More recently, <span class="co">[</span><span class="ot">@shavit_et_al</span><span class="co">]</span> revised the SATzilla</span>
<span id="cb1-230"><a href="#cb1-230" aria-hidden="true" tabindex="-1"></a>feature extractor, showing notable performance improvements with the</span>
<span id="cb1-231"><a href="#cb1-231" aria-hidden="true" tabindex="-1"></a>updated SAT features. In the field of AI planning, studies such as</span>
<span id="cb1-232"><a href="#cb1-232" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@howe2000exploiting; @Fawcett_Vallati_Hutter_Hoffmann_Hoos_Leyton-Brown_2014; @roberts2008makes; @cenamor2013learning</span><span class="co">]</span></span>
<span id="cb1-233"><a href="#cb1-233" aria-hidden="true" tabindex="-1"></a>have contributed by extracting features from the PDDL format of AI</span>
<span id="cb1-234"><a href="#cb1-234" aria-hidden="true" tabindex="-1"></a>planning instances. Although most studies focus on instance features,</span>
<span id="cb1-235"><a href="#cb1-235" aria-hidden="true" tabindex="-1"></a>some have also explored extracting algorithm-specific features and</span>
<span id="cb1-236"><a href="#cb1-236" aria-hidden="true" tabindex="-1"></a>incorporating them into performance model training</span>
<span id="cb1-237"><a href="#cb1-237" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@pmlr-v188-pulatov22a</span><span class="co">]</span>. Algorithm selection using machine learning and</span>
<span id="cb1-238"><a href="#cb1-238" aria-hidden="true" tabindex="-1"></a>statistical analysis is made possible through the extraction and</span>
<span id="cb1-239"><a href="#cb1-239" aria-hidden="true" tabindex="-1"></a>utilization of these features.</span>
<span id="cb1-240"><a href="#cb1-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-241"><a href="#cb1-241" aria-hidden="true" tabindex="-1"></a>Feature selection is only appropriate if its calculation time is</span>
<span id="cb1-242"><a href="#cb1-242" aria-hidden="true" tabindex="-1"></a>considerably less than the time needed to run all the algorithms.</span>
<span id="cb1-243"><a href="#cb1-243" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@Carchrae2005APPLYINGML</span><span class="co">]</span> explored low-knowledge techniques that focus</span>
<span id="cb1-244"><a href="#cb1-244" aria-hidden="true" tabindex="-1"></a>only on observed performance improvement, demonstrating that effective</span>
<span id="cb1-245"><a href="#cb1-245" aria-hidden="true" tabindex="-1"></a>algorithm selection does not always require deep domain knowledge and</span>
<span id="cb1-246"><a href="#cb1-246" aria-hidden="true" tabindex="-1"></a>complex feature extractions and predictive models. In addition, in</span>
<span id="cb1-247"><a href="#cb1-247" aria-hidden="true" tabindex="-1"></a>scenarios where traditional meta-features are hard to obtain, such as</span>
<span id="cb1-248"><a href="#cb1-248" aria-hidden="true" tabindex="-1"></a>image segmentation tasks, verification-based approaches could be used</span>
<span id="cb1-249"><a href="#cb1-249" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@10194439</span><span class="co">]</span>.</span>
<span id="cb1-250"><a href="#cb1-250" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-251"><a href="#cb1-251" aria-hidden="true" tabindex="-1"></a>There is extensive literature on per-instance algorithm selection</span>
<span id="cb1-252"><a href="#cb1-252" aria-hidden="true" tabindex="-1"></a>approaches, developed to resolve various NP-complete and NP-hard</span>
<span id="cb1-253"><a href="#cb1-253" aria-hidden="true" tabindex="-1"></a>problems, including SAT, TSP, and other related challenges</span>
<span id="cb1-254"><a href="#cb1-254" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@satzilla; @10.1007/978-3-642-31612-8_18; @10.1162/evco_a_00215; @Kotthoff2014; @10.1162/evco_a_00242</span><span class="co">]</span>.</span>
<span id="cb1-255"><a href="#cb1-255" aria-hidden="true" tabindex="-1"></a>Some methods are offline, where solvers are selected before solving the</span>
<span id="cb1-256"><a href="#cb1-256" aria-hidden="true" tabindex="-1"></a>problems (e.g., <span class="co">[</span><span class="ot">@satzilla</span><span class="co">]</span>), while others are online, where solvers are</span>
<span id="cb1-257"><a href="#cb1-257" aria-hidden="true" tabindex="-1"></a>continuously selected during the solving process (e.g.,</span>
<span id="cb1-258"><a href="#cb1-258" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@arbelaez2009online</span><span class="co">]</span>).</span>
<span id="cb1-259"><a href="#cb1-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-260"><a href="#cb1-260" aria-hidden="true" tabindex="-1"></a>A large number of studies in the broader literature have examined</span>
<span id="cb1-261"><a href="#cb1-261" aria-hidden="true" tabindex="-1"></a>machine learning-based approaches to tackle the algorithm selection</span>
<span id="cb1-262"><a href="#cb1-262" aria-hidden="true" tabindex="-1"></a>problem, ranging from simple classifiers to complex ensemble approaches.</span>
<span id="cb1-263"><a href="#cb1-263" aria-hidden="true" tabindex="-1"></a>These studies focus on using machine learning algorithms to learn the</span>
<span id="cb1-264"><a href="#cb1-264" aria-hidden="true" tabindex="-1"></a>performance mapping from problem instances to algorithms by extracting</span>
<span id="cb1-265"><a href="#cb1-265" aria-hidden="true" tabindex="-1"></a>features from instances <span class="co">[</span><span class="ot">@Kotthoff2014</span><span class="co">]</span>. To name a few,</span>
<span id="cb1-266"><a href="#cb1-266" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@guo_learning-based_2005</span><span class="co">]</span> has focused on training two classifiers to</span>
<span id="cb1-267"><a href="#cb1-267" aria-hidden="true" tabindex="-1"></a>predict the appropriate exact and approximation algorithms to solve the</span>
<span id="cb1-268"><a href="#cb1-268" aria-hidden="true" tabindex="-1"></a>most probable explanation (MPE) problems. Rule-based systems also play a</span>
<span id="cb1-269"><a href="#cb1-269" aria-hidden="true" tabindex="-1"></a>role in the literature using rules or decision trees to assign</span>
<span id="cb1-270"><a href="#cb1-270" aria-hidden="true" tabindex="-1"></a>algorithms to problem instances based on extracted features</span>
<span id="cb1-271"><a href="#cb1-271" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@ali2006learning</span><span class="co">]</span>. <span class="co">[</span><span class="ot">@NIPS2014_7fb8ceb3</span><span class="co">]</span> considers algorithm selection</span>
<span id="cb1-272"><a href="#cb1-272" aria-hidden="true" tabindex="-1"></a>as a special case of metareasoning and proposes a model for human</span>
<span id="cb1-273"><a href="#cb1-273" aria-hidden="true" tabindex="-1"></a>cognitive strategy selection to solve the sorting problem.</span>
<span id="cb1-274"><a href="#cb1-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-275"><a href="#cb1-275" aria-hidden="true" tabindex="-1"></a>In the ASLib paper, different regression and classification methods are</span>
<span id="cb1-276"><a href="#cb1-276" aria-hidden="true" tabindex="-1"></a>also compared, with the results showing that the RandomForest regression</span>
<span id="cb1-277"><a href="#cb1-277" aria-hidden="true" tabindex="-1"></a>is superior to other methods <span class="co">[</span><span class="ot">@BISCHL201641</span><span class="co">]</span>. Before the implementation</span>
<span id="cb1-278"><a href="#cb1-278" aria-hidden="true" tabindex="-1"></a>of the ASLib data format and library, algorithm selection studies were</span>
<span id="cb1-279"><a href="#cb1-279" aria-hidden="true" tabindex="-1"></a>scattered and many were unaware of each other, so comparing different</span>
<span id="cb1-280"><a href="#cb1-280" aria-hidden="true" tabindex="-1"></a>approaches was challenging due to the absence of a standardized format.</span>
<span id="cb1-281"><a href="#cb1-281" aria-hidden="true" tabindex="-1"></a>ASLib was proposed to standardize model training and to collect</span>
<span id="cb1-282"><a href="#cb1-282" aria-hidden="true" tabindex="-1"></a>benchmarking data in a structured manner which facilitated comparisons</span>
<span id="cb1-283"><a href="#cb1-283" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@BISCHL201641</span><span class="co">]</span>. In response to the need for a fair comparison of</span>
<span id="cb1-284"><a href="#cb1-284" aria-hidden="true" tabindex="-1"></a>different algorithm selection methods, the ICON Challenge on Algorithm</span>
<span id="cb1-285"><a href="#cb1-285" aria-hidden="true" tabindex="-1"></a>Selection was held in 2015 and 2017 <span class="co">[</span><span class="ot">@LINDAUER201986</span><span class="co">]</span>. In 2015, the</span>
<span id="cb1-286"><a href="#cb1-286" aria-hidden="true" tabindex="-1"></a>Zilla system <span class="co">[</span><span class="ot">@satzilla</span><span class="co">]</span> was the winner among eight different methods.</span>
<span id="cb1-287"><a href="#cb1-287" aria-hidden="true" tabindex="-1"></a>In the 2017 challenge, ASAP.v2 <span class="co">[</span><span class="ot">@Gonard2019</span><span class="co">]</span> was the overall winner of</span>
<span id="cb1-288"><a href="#cb1-288" aria-hidden="true" tabindex="-1"></a>eight other methods. The comparison in this competition was conducted</span>
<span id="cb1-289"><a href="#cb1-289" aria-hidden="true" tabindex="-1"></a>using the ASLib format and library.\"</span>
<span id="cb1-290"><a href="#cb1-290" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-291"><a href="#cb1-291" aria-hidden="true" tabindex="-1"></a>Other efforts exist which have not specifically focused on improving</span>
<span id="cb1-292"><a href="#cb1-292" aria-hidden="true" tabindex="-1"></a>algorithm selector choices, but rather on making the decision-making</span>
<span id="cb1-293"><a href="#cb1-293" aria-hidden="true" tabindex="-1"></a>process more intuitive or reducing the cost of performance model</span>
<span id="cb1-294"><a href="#cb1-294" aria-hidden="true" tabindex="-1"></a>training. Some efforts have aimed to improve the transparency of</span>
<span id="cb1-295"><a href="#cb1-295" aria-hidden="true" tabindex="-1"></a>algorithm selection through explainability methods. For example,</span>
<span id="cb1-296"><a href="#cb1-296" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@explainability</span><span class="co">]</span> employed iterative feature selection and SHAP analysis</span>
<span id="cb1-297"><a href="#cb1-297" aria-hidden="true" tabindex="-1"></a>to explain selection decisions. Additionally, the cost of training</span>
<span id="cb1-298"><a href="#cb1-298" aria-hidden="true" tabindex="-1"></a>algorithm selection models can be high due to the need to run candidate</span>
<span id="cb1-299"><a href="#cb1-299" aria-hidden="true" tabindex="-1"></a>algorithms on a representative set of training instances.</span>
<span id="cb1-300"><a href="#cb1-300" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@erdem_ku__2024</span><span class="co">]</span> reduces training costs by selecting a subset of</span>
<span id="cb1-301"><a href="#cb1-301" aria-hidden="true" tabindex="-1"></a>training instances using active learning, with timeout predictors and</span>
<span id="cb1-302"><a href="#cb1-302" aria-hidden="true" tabindex="-1"></a>progressively increasing timeouts to further minimize costs.</span>
<span id="cb1-303"><a href="#cb1-303" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@brighton2002advances</span><span class="co">]</span> has also focused on instance selection which</span>
<span id="cb1-304"><a href="#cb1-304" aria-hidden="true" tabindex="-1"></a>means focusing on choosing a representative set of instances for</span>
<span id="cb1-305"><a href="#cb1-305" aria-hidden="true" tabindex="-1"></a>training, which can help identify the most suitable algorithm and</span>
<span id="cb1-306"><a href="#cb1-306" aria-hidden="true" tabindex="-1"></a>improve algorithm selector efficiency.</span>
<span id="cb1-307"><a href="#cb1-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-308"><a href="#cb1-308" aria-hidden="true" tabindex="-1"></a><span class="fu">## Algorithm Portfolios and Scheduling</span></span>
<span id="cb1-309"><a href="#cb1-309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-310"><a href="#cb1-310" aria-hidden="true" tabindex="-1"></a>In response to the reality that no single algorithm can effectively</span>
<span id="cb1-311"><a href="#cb1-311" aria-hidden="true" tabindex="-1"></a>address all types of problems, the concept of utilizing a portfolio</span>
<span id="cb1-312"><a href="#cb1-312" aria-hidden="true" tabindex="-1"></a>emerged <span class="co">[</span><span class="ot">@GOMES200143</span><span class="co">]</span>. Drawing from the concept of risk diversification</span>
<span id="cb1-313"><a href="#cb1-313" aria-hidden="true" tabindex="-1"></a>in finance, as discussed in <span class="co">[</span><span class="ot">@Huberman1997</span><span class="co">]</span>, it is generally wiser to</span>
<span id="cb1-314"><a href="#cb1-314" aria-hidden="true" tabindex="-1"></a>distribute investments across multiple options rather than concentrating</span>
<span id="cb1-315"><a href="#cb1-315" aria-hidden="true" tabindex="-1"></a>on a single one.</span>
<span id="cb1-316"><a href="#cb1-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-317"><a href="#cb1-317" aria-hidden="true" tabindex="-1"></a>Similarly, to optimize problem solving, an algorithm portfolio includes</span>
<span id="cb1-318"><a href="#cb1-318" aria-hidden="true" tabindex="-1"></a>a diverse set of algorithms with complementary performance</span>
<span id="cb1-319"><a href="#cb1-319" aria-hidden="true" tabindex="-1"></a>characteristics, ensuring that at least one will be effective in solving</span>
<span id="cb1-320"><a href="#cb1-320" aria-hidden="true" tabindex="-1"></a>any given instance. These algorithms often have different probability</span>
<span id="cb1-321"><a href="#cb1-321" aria-hidden="true" tabindex="-1"></a>distributions for runtimes. We can leverage their strengths by combining</span>
<span id="cb1-322"><a href="#cb1-322" aria-hidden="true" tabindex="-1"></a>them into algorithm portfolio approaches to take advantage of</span>
<span id="cb1-323"><a href="#cb1-323" aria-hidden="true" tabindex="-1"></a>differences in probability distributions to enhance overall efficiency</span>
<span id="cb1-324"><a href="#cb1-324" aria-hidden="true" tabindex="-1"></a>as proposed by <span class="co">[</span><span class="ot">@GOMES200143; @Gomes1997AlgorithmPD</span><span class="co">]</span>.</span>
<span id="cb1-325"><a href="#cb1-325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-326"><a href="#cb1-326" aria-hidden="true" tabindex="-1"></a>Subsequently, this portfolio can be leveraged through various methods to</span>
<span id="cb1-327"><a href="#cb1-327" aria-hidden="true" tabindex="-1"></a>use the strengths of multiple algorithms and ultimately reduces risk</span>
<span id="cb1-328"><a href="#cb1-328" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@GOMES200143; @Huberman1997; @Gomes1997AlgorithmPD; @yuri_malitsky__2014</span><span class="co">]</span>.</span>
<span id="cb1-329"><a href="#cb1-329" aria-hidden="true" tabindex="-1"></a>Different portfolio approaches have been proposed to effectively harness</span>
<span id="cb1-330"><a href="#cb1-330" aria-hidden="true" tabindex="-1"></a>the capabilities of multiple complementary algorithms. An approach</span>
<span id="cb1-331"><a href="#cb1-331" aria-hidden="true" tabindex="-1"></a>already discussed in this chapter is algorithm selection, where the</span>
<span id="cb1-332"><a href="#cb1-332" aria-hidden="true" tabindex="-1"></a>objective is to select a single suitable algorithm per instance. Another</span>
<span id="cb1-333"><a href="#cb1-333" aria-hidden="true" tabindex="-1"></a>approach, plain portfolio selection, includes some algorithms that can</span>
<span id="cb1-334"><a href="#cb1-334" aria-hidden="true" tabindex="-1"></a>be executed in parallel on a multicore machine</span>
<span id="cb1-335"><a href="#cb1-335" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@p3s; @flexfolio; @aspeed; @ppfolio; @wotzlawpfoliouzk</span><span class="co">]</span> or sequentially</span>
<span id="cb1-336"><a href="#cb1-336" aria-hidden="true" tabindex="-1"></a>on a single processor by splitting the available time between solvers</span>
<span id="cb1-337"><a href="#cb1-337" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@3s; @lindauer2014algorithm; @flexfolio; @10.5555/2540128.2540217; @satzilla; @cphydra; @sunnycp; @hoos2014claspfolio2advancesalgorithm; @10.5555/3013589.3013607</span><span class="co">]</span>.</span>
<span id="cb1-338"><a href="#cb1-338" aria-hidden="true" tabindex="-1"></a>In addition, numerous alternative approaches have been developed to</span>
<span id="cb1-339"><a href="#cb1-339" aria-hidden="true" tabindex="-1"></a>enable algorithms in the portfolio to cooperate with each other, such as</span>
<span id="cb1-340"><a href="#cb1-340" aria-hidden="true" tabindex="-1"></a>clause sharing, clause exchange, and search space splitting. Ultimately,</span>
<span id="cb1-341"><a href="#cb1-341" aria-hidden="true" tabindex="-1"></a>these approaches outperform any individual algorithm.</span>
<span id="cb1-342"><a href="#cb1-342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-343"><a href="#cb1-343" aria-hidden="true" tabindex="-1"></a>In the plain sequential portfolio domain, over time, a vast body of</span>
<span id="cb1-344"><a href="#cb1-344" aria-hidden="true" tabindex="-1"></a>literature has developed successful sequential portfolio solvers. In</span>
<span id="cb1-345"><a href="#cb1-345" aria-hidden="true" tabindex="-1"></a>particular, 3S <span class="co">[</span><span class="ot">@3s</span><span class="co">]</span> and CSHC <span class="co">[</span><span class="ot">@10.5555/2540128.2540217</span><span class="co">]</span> both secured</span>
<span id="cb1-346"><a href="#cb1-346" aria-hidden="true" tabindex="-1"></a>gold medals in the 2011 and 2013 SAT competitions, respectively.</span>
<span id="cb1-347"><a href="#cb1-347" aria-hidden="true" tabindex="-1"></a>SATZilla <span class="co">[</span><span class="ot">@satzilla</span><span class="co">]</span> won the SAT Challenge 2012, CPHydra <span class="co">[</span><span class="ot">@cphydra</span><span class="co">]</span> was</span>
<span id="cb1-348"><a href="#cb1-348" aria-hidden="true" tabindex="-1"></a>the winner of Intetnational Constraint Solver Competition 2008, and</span>
<span id="cb1-349"><a href="#cb1-349" aria-hidden="true" tabindex="-1"></a>Sunny-CP won MiniZinc Challenge in 2015 <span class="co">[</span><span class="ot">@sunnycp</span><span class="co">]</span>. In addition,</span>
<span id="cb1-350"><a href="#cb1-350" aria-hidden="true" tabindex="-1"></a>Claspfolio <span class="co">[</span><span class="ot">@hoos2014claspfolio2advancesalgorithm</span><span class="co">]</span> earned the gold medal</span>
<span id="cb1-351"><a href="#cb1-351" aria-hidden="true" tabindex="-1"></a>in both the ASP 2009 and 2011 competitions, and IBaCOP2</span>
<span id="cb1-352"><a href="#cb1-352" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@10.5555/3013589.3013607</span><span class="co">]</span> won the Sequential Satisficing Track in the</span>
<span id="cb1-353"><a href="#cb1-353" aria-hidden="true" tabindex="-1"></a>2014 International Planning Competition.</span>
<span id="cb1-354"><a href="#cb1-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-355"><a href="#cb1-355" aria-hidden="true" tabindex="-1"></a>3S <span class="co">[</span><span class="ot">@3s</span><span class="co">]</span> combines solver selection and scheduling. It trains a</span>
<span id="cb1-356"><a href="#cb1-356" aria-hidden="true" tabindex="-1"></a>performance model using K-Nearest Neighbors (KNN) and improves the KNN</span>
<span id="cb1-357"><a href="#cb1-357" aria-hidden="true" tabindex="-1"></a>approach with Distance-Based Weighting and Clustering-Based Adaptive</span>
<span id="cb1-358"><a href="#cb1-358" aria-hidden="true" tabindex="-1"></a>Neighborhood Size. Additionally, they enhanced the model by integrating</span>
<span id="cb1-359"><a href="#cb1-359" aria-hidden="true" tabindex="-1"></a>solver scheduling and testing various approaches such as static</span>
<span id="cb1-360"><a href="#cb1-360" aria-hidden="true" tabindex="-1"></a>scheduling, dynamic scheduling, fixed-time scheduling, and semistatic</span>
<span id="cb1-361"><a href="#cb1-361" aria-hidden="true" tabindex="-1"></a>scheduling. Semi-static scheduling performed best, where 90% of the time</span>
<span id="cb1-362"><a href="#cb1-362" aria-hidden="true" tabindex="-1"></a>was allocated to the solver suggested by the KNN model, and 10% to a</span>
<span id="cb1-363"><a href="#cb1-363" aria-hidden="true" tabindex="-1"></a>static solver schedule, which chose the top solvers averaged over all</span>
<span id="cb1-364"><a href="#cb1-364" aria-hidden="true" tabindex="-1"></a>instances and allocated time statically.</span>
<span id="cb1-365"><a href="#cb1-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-366"><a href="#cb1-366" aria-hidden="true" tabindex="-1"></a>CSHC <span class="co">[</span><span class="ot">@10.5555/2540128.2540217</span><span class="co">]</span> selects a portfolio of solvers using a</span>
<span id="cb1-367"><a href="#cb1-367" aria-hidden="true" tabindex="-1"></a>classification method known as cost-sensitive hierarchical clustering</span>
<span id="cb1-368"><a href="#cb1-368" aria-hidden="true" tabindex="-1"></a>and then sequentially allocates time to each solver. In short, the</span>
<span id="cb1-369"><a href="#cb1-369" aria-hidden="true" tabindex="-1"></a>cost-sensitive hierarchical clustering method selects algorithms by</span>
<span id="cb1-370"><a href="#cb1-370" aria-hidden="true" tabindex="-1"></a>grouping problem instances based on their features and the cost of</span>
<span id="cb1-371"><a href="#cb1-371" aria-hidden="true" tabindex="-1"></a>misclassification. It starts with all instances in one cluster and</span>
<span id="cb1-372"><a href="#cb1-372" aria-hidden="true" tabindex="-1"></a>splits them to maximize agreement on the best algorithm within each</span>
<span id="cb1-373"><a href="#cb1-373" aria-hidden="true" tabindex="-1"></a>cluster. Clusters with too few instances are discarded, and merging is</span>
<span id="cb1-374"><a href="#cb1-374" aria-hidden="true" tabindex="-1"></a>considered if it improves performance.</span>
<span id="cb1-375"><a href="#cb1-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-376"><a href="#cb1-376" aria-hidden="true" tabindex="-1"></a>In SATZilla <span class="co">[</span><span class="ot">@satzilla</span><span class="co">]</span>, seven solvers are selected by manually</span>
<span id="cb1-377"><a href="#cb1-377" aria-hidden="true" tabindex="-1"></a>analyzing competition results to identify algorithms that perform best</span>
<span id="cb1-378"><a href="#cb1-378" aria-hidden="true" tabindex="-1"></a>on specific subsets of instances. An empirical hardness model, trained</span>
<span id="cb1-379"><a href="#cb1-379" aria-hidden="true" tabindex="-1"></a>on instance features, is then used to select the most appropriate solver</span>
<span id="cb1-380"><a href="#cb1-380" aria-hidden="true" tabindex="-1"></a>for each instance. Additionally, SATZilla employs presolvers, typically</span>
<span id="cb1-381"><a href="#cb1-381" aria-hidden="true" tabindex="-1"></a>two, that run before the main solver, quickly resolving instances that</span>
<span id="cb1-382"><a href="#cb1-382" aria-hidden="true" tabindex="-1"></a>are easy to solve. For harder instances which did not get resolved in</span>
<span id="cb1-383"><a href="#cb1-383" aria-hidden="true" tabindex="-1"></a>the presolver phase, one solver is chosen from the seven based on the</span>
<span id="cb1-384"><a href="#cb1-384" aria-hidden="true" tabindex="-1"></a>model's predictions, and the remaining time is allocated to this solver</span>
<span id="cb1-385"><a href="#cb1-385" aria-hidden="true" tabindex="-1"></a>based on its expected performance.</span>
<span id="cb1-386"><a href="#cb1-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-387"><a href="#cb1-387" aria-hidden="true" tabindex="-1"></a>CPHydra <span class="co">[</span><span class="ot">@cphydra</span><span class="co">]</span> is another sequential algorithm portfolio approach</span>
<span id="cb1-388"><a href="#cb1-388" aria-hidden="true" tabindex="-1"></a>designed to solve constraint satisfaction problems using case-based</span>
<span id="cb1-389"><a href="#cb1-389" aria-hidden="true" tabindex="-1"></a>reasoning (CBR). CBR is a lazy machine learning method in which no model</span>
<span id="cb1-390"><a href="#cb1-390" aria-hidden="true" tabindex="-1"></a>is explicitly trained; instead, the selection is based on past cases and</span>
<span id="cb1-391"><a href="#cb1-391" aria-hidden="true" tabindex="-1"></a>experiences. CPHydra uses syntactic features, such as the average and</span>
<span id="cb1-392"><a href="#cb1-392" aria-hidden="true" tabindex="-1"></a>maximum domain size, and solver-specific features, including recorded</span>
<span id="cb1-393"><a href="#cb1-393" aria-hidden="true" tabindex="-1"></a>search statistics, number of explored nodes, and runtime, which describe</span>
<span id="cb1-394"><a href="#cb1-394" aria-hidden="true" tabindex="-1"></a>the problem instance. Subsequently, the KNN algorithm is employed to</span>
<span id="cb1-395"><a href="#cb1-395" aria-hidden="true" tabindex="-1"></a>query the top k (with k set to 10) similar cases to the current problem</span>
<span id="cb1-396"><a href="#cb1-396" aria-hidden="true" tabindex="-1"></a>instance to choose the dominated solvers. The available CPU time limit</span>
<span id="cb1-397"><a href="#cb1-397" aria-hidden="true" tabindex="-1"></a>is then divided among multiple solvers, in contrast to approaches such</span>
<span id="cb1-398"><a href="#cb1-398" aria-hidden="true" tabindex="-1"></a>as SATzilla, which rely on a single solver. This division is formulated</span>
<span id="cb1-399"><a href="#cb1-399" aria-hidden="true" tabindex="-1"></a>as a small knapsack problem with the aim of maximizing the probability</span>
<span id="cb1-400"><a href="#cb1-400" aria-hidden="true" tabindex="-1"></a>of finding a solution. The scheduling is computed to maximize the number</span>
<span id="cb1-401"><a href="#cb1-401" aria-hidden="true" tabindex="-1"></a>of similar cases that can be solved using the assigned schedule.</span>
<span id="cb1-402"><a href="#cb1-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-403"><a href="#cb1-403" aria-hidden="true" tabindex="-1"></a>Claspfolio <span class="co">[</span><span class="ot">@10.1007/978-3-642-20895-9_40</span><span class="co">]</span> considers multiple</span>
<span id="cb1-404"><a href="#cb1-404" aria-hidden="true" tabindex="-1"></a>configurations of the clasp ASP solver and uses support vector</span>
<span id="cb1-405"><a href="#cb1-405" aria-hidden="true" tabindex="-1"></a>regression (SVR) to select suitable solvers. Claspfolio is composed of</span>
<span id="cb1-406"><a href="#cb1-406" aria-hidden="true" tabindex="-1"></a>four key parts: an ASP grounder, gringo; a lightweight clasp solver</span>
<span id="cb1-407"><a href="#cb1-407" aria-hidden="true" tabindex="-1"></a>called claspre (which extracts features from the problem instance); a</span>
<span id="cb1-408"><a href="#cb1-408" aria-hidden="true" tabindex="-1"></a>scoring mechanism that evaluates clasp configurations based on the</span>
<span id="cb1-409"><a href="#cb1-409" aria-hidden="true" tabindex="-1"></a>extracted features; and finally, the configuration with the highest</span>
<span id="cb1-410"><a href="#cb1-410" aria-hidden="true" tabindex="-1"></a>score is selected to solve the instance. There is no explicit scheduling</span>
<span id="cb1-411"><a href="#cb1-411" aria-hidden="true" tabindex="-1"></a>in the original Claspfolio approach, but it is considered a sequential</span>
<span id="cb1-412"><a href="#cb1-412" aria-hidden="true" tabindex="-1"></a>portfolio approach because it selects one solver configuration and runs</span>
<span id="cb1-413"><a href="#cb1-413" aria-hidden="true" tabindex="-1"></a>it sequentially. <span class="co">[</span><span class="ot">@hoos2014claspfolio2advancesalgorithm</span><span class="co">]</span> later</span>
<span id="cb1-414"><a href="#cb1-414" aria-hidden="true" tabindex="-1"></a>introduced Claspfolio2, which includes a solver schedule based on a</span>
<span id="cb1-415"><a href="#cb1-415" aria-hidden="true" tabindex="-1"></a>pre-solving method. This approach employs a timeout-minimal pre-solving</span>
<span id="cb1-416"><a href="#cb1-416" aria-hidden="true" tabindex="-1"></a>schedule using ASPEED <span class="co">[</span><span class="ot">@aspeed</span><span class="co">]</span>, where each solver is assigned a</span>
<span id="cb1-417"><a href="#cb1-417" aria-hidden="true" tabindex="-1"></a>specific time budget to solve a given instance. Although ASPEED is</span>
<span id="cb1-418"><a href="#cb1-418" aria-hidden="true" tabindex="-1"></a>capable of handling multicore scheduling, Claspfolio2 primarily focuses</span>
<span id="cb1-419"><a href="#cb1-419" aria-hidden="true" tabindex="-1"></a>on sequential scheduling, maintaining the original approach's emphasis</span>
<span id="cb1-420"><a href="#cb1-420" aria-hidden="true" tabindex="-1"></a>on running solvers one after another.</span>
<span id="cb1-421"><a href="#cb1-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-422"><a href="#cb1-422" aria-hidden="true" tabindex="-1"></a>IBaCOP <span class="co">[</span><span class="ot">@10.5555/3013589.3013607</span><span class="co">]</span> is a portfolio approach in the</span>
<span id="cb1-423"><a href="#cb1-423" aria-hidden="true" tabindex="-1"></a>planning domain. It designs a portfolio by creating a per-instance</span>
<span id="cb1-424"><a href="#cb1-424" aria-hidden="true" tabindex="-1"></a>configurable portfolio rather than using a fixed configuration. The</span>
<span id="cb1-425"><a href="#cb1-425" aria-hidden="true" tabindex="-1"></a>design process involves selecting a set of planners (five in the</span>
<span id="cb1-426"><a href="#cb1-426" aria-hidden="true" tabindex="-1"></a>experiments) to narrow down those likely to perform well for a given</span>
<span id="cb1-427"><a href="#cb1-427" aria-hidden="true" tabindex="-1"></a>task. This selection is done using Pareto efficiency, choosing planners</span>
<span id="cb1-428"><a href="#cb1-428" aria-hidden="true" tabindex="-1"></a>that offer a balance between different performance criteria without</span>
<span id="cb1-429"><a href="#cb1-429" aria-hidden="true" tabindex="-1"></a>being dominated by others. The selected planners are then allocated a</span>
<span id="cb1-430"><a href="#cb1-430" aria-hidden="true" tabindex="-1"></a>portion of time on a single processor. IBaCOP <span class="co">[</span><span class="ot">@cenamor2014ibacop</span><span class="co">]</span> was</span>
<span id="cb1-431"><a href="#cb1-431" aria-hidden="true" tabindex="-1"></a>later developed based on the previous version, but more planners were</span>
<span id="cb1-432"><a href="#cb1-432" aria-hidden="true" tabindex="-1"></a>included in the method, and a performance prediction model was trained</span>
<span id="cb1-433"><a href="#cb1-433" aria-hidden="true" tabindex="-1"></a>instead of using Pareto efficiency for choosing the sub-portfolio,</span>
<span id="cb1-434"><a href="#cb1-434" aria-hidden="true" tabindex="-1"></a>making the selection dynamic.</span>
<span id="cb1-435"><a href="#cb1-435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-436"><a href="#cb1-436" aria-hidden="true" tabindex="-1"></a>SNNAP <span class="co">[</span><span class="ot">@collautti2013snnap</span><span class="co">]</span> is a KNN-based approach for solving SAT</span>
<span id="cb1-437"><a href="#cb1-437" aria-hidden="true" tabindex="-1"></a>problems that combines supervised and unsupervised learning to create a</span>
<span id="cb1-438"><a href="#cb1-438" aria-hidden="true" tabindex="-1"></a>solver portfolio. It uses random forests to predict the runtime of</span>
<span id="cb1-439"><a href="#cb1-439" aria-hidden="true" tabindex="-1"></a>solvers on specific instances, and based on these predictions, it</span>
<span id="cb1-440"><a href="#cb1-440" aria-hidden="true" tabindex="-1"></a>selects similar instances from the training set using KNN, choosing the</span>
<span id="cb1-441"><a href="#cb1-441" aria-hidden="true" tabindex="-1"></a>top-performing solvers predicted to perform well on the given instance.</span>
<span id="cb1-442"><a href="#cb1-442" aria-hidden="true" tabindex="-1"></a>The value of k is defined by the user, with the top three solvers being</span>
<span id="cb1-443"><a href="#cb1-443" aria-hidden="true" tabindex="-1"></a>selected. SNNAP has been shown to outperform ISAC <span class="co">[</span><span class="ot">@kadioglu2010isac</span><span class="co">]</span>, a</span>
<span id="cb1-444"><a href="#cb1-444" aria-hidden="true" tabindex="-1"></a>method for the configuration of algorithm based on instance that</span>
<span id="cb1-445"><a href="#cb1-445" aria-hidden="true" tabindex="-1"></a>ultimately selects a single algorithm, in experiments. The available</span>
<span id="cb1-446"><a href="#cb1-446" aria-hidden="true" tabindex="-1"></a>time is divided between the selected solvers, and they are run</span>
<span id="cb1-447"><a href="#cb1-447" aria-hidden="true" tabindex="-1"></a>sequentially.</span>
<span id="cb1-448"><a href="#cb1-448" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-449"><a href="#cb1-449" aria-hidden="true" tabindex="-1"></a>Sunny <span class="co">[</span><span class="ot">@sunny</span><span class="co">]</span> is a portfolio designed to solve constraint satisfaction</span>
<span id="cb1-450"><a href="#cb1-450" aria-hidden="true" tabindex="-1"></a>problems (CSP). It uses KNN to select a subset of training instances</span>
<span id="cb1-451"><a href="#cb1-451" aria-hidden="true" tabindex="-1"></a>that are closest to the problem at hand. It then computes a schedule of</span>
<span id="cb1-452"><a href="#cb1-452" aria-hidden="true" tabindex="-1"></a>solvers that solve the maximum number of instances within a specific</span>
<span id="cb1-453"><a href="#cb1-453" aria-hidden="true" tabindex="-1"></a>time limit, allocating a portion of time to each solver to create a</span>
<span id="cb1-454"><a href="#cb1-454" aria-hidden="true" tabindex="-1"></a>schedule. It also includes a backup solver to handle exceptional cases.</span>
<span id="cb1-455"><a href="#cb1-455" aria-hidden="true" tabindex="-1"></a>Sunny-CP <span class="co">[</span><span class="ot">@sunnycp</span><span class="co">]</span> is based on Sunny and extends its capabilities to</span>
<span id="cb1-456"><a href="#cb1-456" aria-hidden="true" tabindex="-1"></a>handle both CSPs and constraint optimization problems (COPs). Sunny-CP</span>
<span id="cb1-457"><a href="#cb1-457" aria-hidden="true" tabindex="-1"></a>includes an improved feature extraction tool compared to Sunny. Both</span>
<span id="cb1-458"><a href="#cb1-458" aria-hidden="true" tabindex="-1"></a>Sunny and Sunny-CP are sequential portfolio designs.</span>
<span id="cb1-459"><a href="#cb1-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-460"><a href="#cb1-460" aria-hidden="true" tabindex="-1"></a>AutoFolio <span class="co">[</span><span class="ot">@lindauer2015autofolio</span><span class="co">]</span> is another effort that integrates</span>
<span id="cb1-461"><a href="#cb1-461" aria-hidden="true" tabindex="-1"></a>various algorithm and portfolio selection approaches. It is built on the</span>
<span id="cb1-462"><a href="#cb1-462" aria-hidden="true" tabindex="-1"></a>claspfolio2 framework and employs a highly parametric framework for</span>
<span id="cb1-463"><a href="#cb1-463" aria-hidden="true" tabindex="-1"></a>algorithm selection. AutoFolio is a general-purpose system,</span>
<span id="cb1-464"><a href="#cb1-464" aria-hidden="true" tabindex="-1"></a>incorporating techniques from systems like 3S, ISAC, SATzilla, SNAPP as</span>
<span id="cb1-465"><a href="#cb1-465" aria-hidden="true" tabindex="-1"></a>well as multiclass classification, pairwise classification, and various</span>
<span id="cb1-466"><a href="#cb1-466" aria-hidden="true" tabindex="-1"></a>regression methods. Unlike many other systems, AutoFolio is not specific</span>
<span id="cb1-467"><a href="#cb1-467" aria-hidden="true" tabindex="-1"></a>to any particular problem domain, aiming instead to harness the</span>
<span id="cb1-468"><a href="#cb1-468" aria-hidden="true" tabindex="-1"></a>strengths of each algorithm selection approach it includes. However, it</span>
<span id="cb1-469"><a href="#cb1-469" aria-hidden="true" tabindex="-1"></a>does not focus on parallel portfolios.</span>
<span id="cb1-470"><a href="#cb1-470" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-471"><a href="#cb1-471" aria-hidden="true" tabindex="-1"></a>A recent sequential portfolio design is MedleySolver</span>
<span id="cb1-472"><a href="#cb1-472" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@10.1007/978-3-030-80223-3_31</span><span class="co">]</span>, which is designed to solve</span>
<span id="cb1-473"><a href="#cb1-473" aria-hidden="true" tabindex="-1"></a>satisfiability modulo theories (SMT) problems. In this method, multiple</span>
<span id="cb1-474"><a href="#cb1-474" aria-hidden="true" tabindex="-1"></a>solvers are selected based on the multi-armed bandit (MAB) framework and</span>
<span id="cb1-475"><a href="#cb1-475" aria-hidden="true" tabindex="-1"></a>run sequentially. MAB models a situation where an agent must choose</span>
<span id="cb1-476"><a href="#cb1-476" aria-hidden="true" tabindex="-1"></a>between multiple options, balancing the trade-off between exploring new</span>
<span id="cb1-477"><a href="#cb1-477" aria-hidden="true" tabindex="-1"></a>solvers and exploiting the best-known solvers for the highest reward.</span>
<span id="cb1-478"><a href="#cb1-478" aria-hidden="true" tabindex="-1"></a>MedleySolver essentially provides an ordering for a sequence of SMT</span>
<span id="cb1-479"><a href="#cb1-479" aria-hidden="true" tabindex="-1"></a>solvers and splits available time between solvers.</span>
<span id="cb1-480"><a href="#cb1-480" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-481"><a href="#cb1-481" aria-hidden="true" tabindex="-1"></a>In the domain of parallel portfolio solvers, the Plain Parallel</span>
<span id="cb1-482"><a href="#cb1-482" aria-hidden="true" tabindex="-1"></a>Portfolio (PPP) approach involves running multiple solvers on same</span>
<span id="cb1-483"><a href="#cb1-483" aria-hidden="true" tabindex="-1"></a>instance in parallel, leveraging multi-core shared memory architectures</span>
<span id="cb1-484"><a href="#cb1-484" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@conf/sat/AignerBKNP13</span><span class="co">]</span>. In this approach, sequential solvers are</span>
<span id="cb1-485"><a href="#cb1-485" aria-hidden="true" tabindex="-1"></a>treated as \"black boxes\", they do not share any information with each</span>
<span id="cb1-486"><a href="#cb1-486" aria-hidden="true" tabindex="-1"></a>other, and as soon as any solver resolves the instance, the entire</span>
<span id="cb1-487"><a href="#cb1-487" aria-hidden="true" tabindex="-1"></a>process stops <span class="co">[</span><span class="ot">@conf/sat/AignerBKNP13; @Marius2015</span><span class="co">]</span>. Some PPP methods</span>
<span id="cb1-488"><a href="#cb1-488" aria-hidden="true" tabindex="-1"></a>are static, where the sub-portfolios are selected to run on all problems</span>
<span id="cb1-489"><a href="#cb1-489" aria-hidden="true" tabindex="-1"></a>and are not instance-based. Notable examples of static PPP solvers in</span>
<span id="cb1-490"><a href="#cb1-490" aria-hidden="true" tabindex="-1"></a>the SAT domain include ManySAT <span class="co">[</span><span class="ot">@Hamadi2009</span><span class="co">]</span>, ppfolio <span class="co">[</span><span class="ot">@ppfolio</span><span class="co">]</span>,</span>
<span id="cb1-491"><a href="#cb1-491" aria-hidden="true" tabindex="-1"></a>pfolioUZK <span class="co">[</span><span class="ot">@wotzlawpfoliouzk</span><span class="co">]</span>, with ppfolio excelling in the 2011 SAT</span>
<span id="cb1-492"><a href="#cb1-492" aria-hidden="true" tabindex="-1"></a>Competition. The PPP approach typically selects the top solvers that</span>
<span id="cb1-493"><a href="#cb1-493" aria-hidden="true" tabindex="-1"></a>consistently outperform others on average. This approach has also been</span>
<span id="cb1-494"><a href="#cb1-494" aria-hidden="true" tabindex="-1"></a>used in methods such as SATZilla, where a presolving phase, as mentioned</span>
<span id="cb1-495"><a href="#cb1-495" aria-hidden="true" tabindex="-1"></a>above, is employed <span class="co">[</span><span class="ot">@satzilla</span><span class="co">]</span>. However, this strategy often overlooks</span>
<span id="cb1-496"><a href="#cb1-496" aria-hidden="true" tabindex="-1"></a>solvers that, while less dominant overall, may significantly outperform</span>
<span id="cb1-497"><a href="#cb1-497" aria-hidden="true" tabindex="-1"></a>the top solvers in specific instances.</span>
<span id="cb1-498"><a href="#cb1-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-499"><a href="#cb1-499" aria-hidden="true" tabindex="-1"></a>To address these limitations, more innovative approaches, such as P3S</span>
<span id="cb1-500"><a href="#cb1-500" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@p3s</span><span class="co">]</span>, have been introduced. P3S is a parallel version of 3S <span class="co">[</span><span class="ot">@3s</span><span class="co">]</span> and</span>
<span id="cb1-501"><a href="#cb1-501" aria-hidden="true" tabindex="-1"></a>participated in the SAT Challenge 2012. It uses the same method as 3S</span>
<span id="cb1-502"><a href="#cb1-502" aria-hidden="true" tabindex="-1"></a>but operates in parallel. ASPEED <span class="co">[</span><span class="ot">@aspeed</span><span class="co">]</span>, a static ASP technique,</span>
<span id="cb1-503"><a href="#cb1-503" aria-hidden="true" tabindex="-1"></a>defines a fixed schedule for multiple solvers to run in parallel,</span>
<span id="cb1-504"><a href="#cb1-504" aria-hidden="true" tabindex="-1"></a>solving this scheduling problem using answer set programming. Sunny-cp2</span>
<span id="cb1-505"><a href="#cb1-505" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@sunnycp2</span><span class="co">]</span> is another approach, a parallel version of Sunny-cp,</span>
<span id="cb1-506"><a href="#cb1-506" aria-hidden="true" tabindex="-1"></a>designed for the parallel execution of constraint satisfaction and</span>
<span id="cb1-507"><a href="#cb1-507" aria-hidden="true" tabindex="-1"></a>constraint optimization solvers. We will discuss these approaches in</span>
<span id="cb1-508"><a href="#cb1-508" aria-hidden="true" tabindex="-1"></a>more detail in Chapter 4, where we introduce another approach in this</span>
<span id="cb1-509"><a href="#cb1-509" aria-hidden="true" tabindex="-1"></a>field that surpasses the options currently available in the literature.</span>
<span id="cb1-510"><a href="#cb1-510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-511"><a href="#cb1-511" aria-hidden="true" tabindex="-1"></a>ArvandHerd <span class="co">[</span><span class="ot">@10.5555/3007337.3007474</span><span class="co">]</span> is another example of parallel</span>
<span id="cb1-512"><a href="#cb1-512" aria-hidden="true" tabindex="-1"></a>portfolio design, but in planning problems. This method won tracks in</span>
<span id="cb1-513"><a href="#cb1-513" aria-hidden="true" tabindex="-1"></a>the 2011 Planning Competition. The portfolio includes multiple</span>
<span id="cb1-514"><a href="#cb1-514" aria-hidden="true" tabindex="-1"></a>configurations of two different planners. Typically, on three cores, two</span>
<span id="cb1-515"><a href="#cb1-515" aria-hidden="true" tabindex="-1"></a>cores are dedicated to running multiple configurations of the Arvand</span>
<span id="cb1-516"><a href="#cb1-516" aria-hidden="true" tabindex="-1"></a>solver, while one core is allocated to LAMA-2008 solver configurations.</span>
<span id="cb1-517"><a href="#cb1-517" aria-hidden="true" tabindex="-1"></a>The process starts with one configuration, and if that configuration</span>
<span id="cb1-518"><a href="#cb1-518" aria-hidden="true" tabindex="-1"></a>exhausts the memory, the planner restarts with another configuration.</span>
<span id="cb1-519"><a href="#cb1-519" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-520"><a href="#cb1-520" aria-hidden="true" tabindex="-1"></a>Although there have been many studies on plain portfolio designs, no</span>
<span id="cb1-521"><a href="#cb1-521" aria-hidden="true" tabindex="-1"></a>plain portfolio solvers have been accepted into the SAT competition</span>
<span id="cb1-522"><a href="#cb1-522" aria-hidden="true" tabindex="-1"></a>since 2020 <span class="co">[</span><span class="ot">@FROLEYKS2021103572</span><span class="co">]</span>. Prior to 2020, and since the SAT</span>
<span id="cb1-523"><a href="#cb1-523" aria-hidden="true" tabindex="-1"></a>Competition 2016, plain portfolio solvers had the opportunity to enter</span>
<span id="cb1-524"><a href="#cb1-524" aria-hidden="true" tabindex="-1"></a>the No Limit track where submitting the source code was not required.</span>
<span id="cb1-525"><a href="#cb1-525" aria-hidden="true" tabindex="-1"></a>Before 2016, they were accepted as regular solvers, which is why we only</span>
<span id="cb1-526"><a href="#cb1-526" aria-hidden="true" tabindex="-1"></a>have gold medalists and winning plain portfolio approaches related to</span>
<span id="cb1-527"><a href="#cb1-527" aria-hidden="true" tabindex="-1"></a>competitions before 2016. Cooperative portfolio solvers, on the other</span>
<span id="cb1-528"><a href="#cb1-528" aria-hidden="true" tabindex="-1"></a>hand, have been accepted in all tracks, especially in the parallel track</span>
<span id="cb1-529"><a href="#cb1-529" aria-hidden="true" tabindex="-1"></a>of the SAT competition. In this portfolio approach, solvers can</span>
<span id="cb1-530"><a href="#cb1-530" aria-hidden="true" tabindex="-1"></a>communicate, share learned clauses, or split search spaces to improve</span>
<span id="cb1-531"><a href="#cb1-531" aria-hidden="true" tabindex="-1"></a>efficiency and performance.</span>
<span id="cb1-532"><a href="#cb1-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-533"><a href="#cb1-533" aria-hidden="true" tabindex="-1"></a>For example, PRS-parallel, a parallel portfolio solver capable of</span>
<span id="cb1-534"><a href="#cb1-534" aria-hidden="true" tabindex="-1"></a>running in distributed environments, supports clause sharing and won the</span>
<span id="cb1-535"><a href="#cb1-535" aria-hidden="true" tabindex="-1"></a>parallel track of the 2023 SAT Competition <span class="co">[</span><span class="ot">@sat2023</span><span class="co">]</span>. PaKis, the</span>
<span id="cb1-536"><a href="#cb1-536" aria-hidden="true" tabindex="-1"></a>parallel portfolio solver that won the parallel track of the 2021 SAT</span>
<span id="cb1-537"><a href="#cb1-537" aria-hidden="true" tabindex="-1"></a>Competition, relies on different configurations of the Kissat solver but</span>
<span id="cb1-538"><a href="#cb1-538" aria-hidden="true" tabindex="-1"></a>does not support information sharing between solvers <span class="co">[</span><span class="ot">@sat2021</span><span class="co">]</span>. There</span>
<span id="cb1-539"><a href="#cb1-539" aria-hidden="true" tabindex="-1"></a>is a vast body of literature on cooperative portfolios, which is beyond</span>
<span id="cb1-540"><a href="#cb1-540" aria-hidden="true" tabindex="-1"></a>the scope of this chapter.</span></code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p><a href="https://haniyeka.github.io">Website</a> | <a href="https://github.com/haniyeka">GitHub</a> | <a href="https://github.com/uwyo-mallet">UWYO-Mallet</a></p>
</div>
    <div class="nav-footer-right">
<p>Built with <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>




<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>